/***********************************************************************
** Copyright (C) CHENQIANG . All rights reserved.
** Author			: CHEN QIANG
** Date				: 2014.03.05
** Name				: onvif_client.c
** Version			: 1.0
** Description			: onvif
*  //标注
* 1 ，先假设本机只有一个网卡
* 2 ，数据不进行过滤
* 
* 
***********************************************************************/

#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <stdint.h>
#include "soapH.h"
#include "soapStub.h" 
#include "nsmap.h"
#include <string.h>
#include "onvif_client.h"
#include "onvif_header.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <pthread.h>

#define	MULTICAST_ADDRESS "soap.udp://239.255.255.250:3702"		//multicast address and port 

static  pthread_mutex_t onvif_data_mutex= PTHREAD_MUTEX_INITIALIZER;
//pthread_mutex_t onvif_data_mutex ;


//发送onvif命令的超时时间
static int  g_onvif_time_out =  3 ;
#ifndef ONVIF_TIMEOUT
#define ONVIF_TIMEOUT
#endif


#if 1
#define ONVIF_DBP(fmt, args...) do { fprintf(stderr, "\n========= [%s ] %s line %d " fmt "\n", __FILE__, __FUNCTION__, __LINE__, ##args ); fflush(stderr);   } while ( 0 )
#else
#define ONVIF_DBP(fmt, args...) 
#endif

extern  int DevPort ;
extern  char DevIp[MAX_LEN] ;
static int MaxCamera = 32;
ONVIF_CAMERAS g_onvifCameras  ;

void ONVIF_GetIPAndPort(unsigned short *DevicePort,  char * DeviceIP, const char * ServiceXAddr)
{
    //去除''http://"前缀"
    char XAddrBuff[256] ={0};
    strncpy(XAddrBuff,ServiceXAddr +7,255);
    XAddrBuff[255] = '\0';

    int j = 0;
    bool bReadPort = false;//是否开始读取端口号
    unsigned short l_Port = 0;//临时存储端口
    char l_IPAddr[256] = {0};
    unsigned int i;
    for( i = 0; i <= strlen(XAddrBuff); ++i)
    {
        if(XAddrBuff[i] == '/'  &&  !bReadPort)
        {
            //默认端口
            l_Port = 80;
            break;
        }
        else if(XAddrBuff[i] == ':')
        {
            bReadPort = true;//开始读取端口号
        }
        else if(bReadPort)
        {
            if(isdigit(XAddrBuff[i]))
            {
                l_Port = 10 * l_Port +( XAddrBuff[i] - '0') ;
            }
            else
            {
                break;
            }
        }
        else
        {
            DeviceIP[j++] = XAddrBuff[i];
        }
    }
    DeviceIP[j] = '\0';
    *DevicePort = l_Port;
}


const char* soap_wsa_rand_uuid(struct soap *soap)
{
    const int uuidlen = 48;
    char *uuid = (char*)soap_malloc(soap, uuidlen);
    int r1, r2, r3, r4;
#ifdef WITH_OPENSSL
    r1 = soap_random;
    r2 = soap_random;
#else
    static int k = 0xFACEB00B;
    int lo = k % 127773;
    int hi = k / 127773;
# ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
    gettimeofday(&tv, NULL);
    r1 = 10000000 * tv.tv_sec + tv.tv_usec;
#else
    r1 = (int)time(NULL);
# endif
    k = 16807 * lo - 2836 * hi;
    if (k <= 0)
        k += 0x7FFFFFFF;
    r2 = k;
    k &= 0x8FFFFFFF;
    r2 += *(int*)soap->buf;
#endif
    r3 = soap_random;
    r4 = soap_random;
    //#ifdef HAVE_SNPRINTF
    //  soap_snprintf(uuid, uuidlen, "urn:uuid:%8.8x-%4.4hx-4%3.3hx-%4.4hx-%4.4hx%8.8x", r1, (short)(r2 >> 16), ((short)r2 >> 4) & 0x0FFF, ((short)(r3 >> 16) & 0x3FFF) | 0x8000, (short)r3, r4);
    //#else
    sprintf(uuid, "urn:uuid:%8.8x-%4.4hx-4%3.3hx-%4.4hx-%4.4hx%8.8x", r1, (short)(r2 >> 16), ((short)r2 >> 4) & 0x0FFF, ((short)(r3 >> 16) & 0x3FFF) | 0x8000, (short)r3, r4);
    //#endif
    DBGFUN1("soap_wsa_rand_uuid", "%s", uuid);
    return uuid;
}



typedef struct _IP
{
    char IPaddr[MAX_LEN];
}IP;

# if 0
int Compare(const void *elem1, const void *elem2)
{
    int i;
    IP *ptem1 = (IP*)elem1;
    IP *ptem2 = (IP*)elem2;
    //从ip地址的网段地址开始比较
    for (i = 2; i < 4; i++)
    {
        if (ptem1->IPblock[i] < ptem2->IPblock[i])
        {
            return -1;
        }
        else if (ptem1->IPblock[i] > ptem2->IPblock[i])
        {
            return 1;
        }
    }
    return 0;
}
#endif

bool Lookup(int count,IP * Allip,char * strip)
{

    if(0==count)
        return false ;
    int i;
    for(i=0; i!=count;++i)
    {
        if(!strncmp(Allip[i].IPaddr,strip,MAX_LEN))
        {
            return true ;
        }
        else
        {
            continue;
        }
    }

    return false ;

}





int StartDiscovery( Discovery_Callback pCallback)
{
    int count = 0 ;
    int result = 0;
    wsdd__ProbeType req;
    struct  __wsdd__ProbeMatches resp;
    wsdd__ScopesType sScope;
    struct SOAP_ENV__Header header;
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = 3;
    soap->recv_timeout = 3;
    soap->send_timeout = 3;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_default_SOAP_ENV__Header(soap, &header);

    header.wsa__MessageID = (char * )soap_wsa_rand_uuid(soap);
    header.wsa__To = "urn:schemas-xmlsoap-org:ws:2005:04:discovery";
    header.wsa__Action = "http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe";
    soap->header = &header;

    soap_default_wsdd__ScopesType(soap, &sScope);
    sScope.__item = "";
    soap_default_wsdd__ProbeType(soap, &req);
    req.Scopes = &sScope;
    //命名空间和前缀必须要对应
    req.Types = "dn:NetworkVideoTransmitter";
    result = soap_send___wsdd__Probe(soap, MULTICAST_ADDRESS, NULL, &req);
    if(result != SOAP_OK)
    {
        printf("send probe err \r\n");
        return -1 ;
    }
    int j ;
    unsigned short DevicePort = 0 ;
    char DeviceIp[MAX_LEN] = {0};
    IP Allip[256] = {0};
    for(j =0;j<256 ;++j)
    {
        bool l_status = false ;   //表明探测状态，区分已经探测到设备后（探测设备完成）和探测超时
        result = soap_recv___wsdd__ProbeMatches(soap, &resp);
        ONVIF_DBP("################### return  new lib ===%d !!!!!!!!!!!#######################！\r\n",result);
        if(result == SOAP_OK)
        {
            if(soap->error)
            {
                ONVIF_DBP("#####################found device but err #######################！\r\n");
                ONVIF_DBP("soap error 1: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap));
                result = soap->error;
                continue;
            }
            else
            {
                l_status = true ;
                ONVIF_DBP("###################new lib found device !!!!!!!!!!!#######################！\r\n");
                ONVIF_GetIPAndPort(&DevicePort,DeviceIp,resp.wsdd__ProbeMatches->ProbeMatch->XAddrs);
#if 0
                if(DeviceIp[0]!=0)
                {
                    sscanf(DeviceIp,"%d.%d.%d.%d",&allIP[j].IPblock[0],&allIP[j].IPblock[1],&allIP[j].IPblock[2],&allIP[j].IPblock[3]);
                    allIP[j].port = DevicePort;
                    strcpy(allIP[j].devuuid,resp.wsdd__ProbeMatches->ProbeMatch->wsa__EndpointReference.Address);
                }
#endif
                if(isdigit(DeviceIp[0]))
                {
                    if(!Lookup(count,Allip,DeviceIp))
                    {
                        pCallback(DeviceIp,DevicePort,resp.wsdd__ProbeMatches->ProbeMatch->wsa__EndpointReference.Address);
                        strncpy(Allip[count].IPaddr,DeviceIp,MAX_LEN);
                        count++ ;
                    }
                }

            }
        }
        else if (result == -1)
        {
            if(l_status ==false)
            {
                ONVIF_DBP("#####################time out #######################！\r\n");
                break;
            }
        }
    }
#if 0
    //ip地址排序
    qsort(allIP, count, sizeof(IP), Compare);
    for (i = 0; i < count; i++)
    {
        if(allIP[i].IPblock[0])
        {
            sprintf(DeviceIp,"%d.%d.%d.%d", allIP[i].IPblock[0], allIP[i].IPblock[1], allIP[i].IPblock[2], allIP[i].IPblock[3]);
            pCallback(DeviceIp,allIP[i].port,allIP[i].devuuid);
        }
    }
#endif
    ONVIF_DBP("###################NUM = %d !!!!!!!!!!!#######################！\r\n",count);
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    ONVIF_DBP("##########################discovery finish ！！！！############################### !\n");
    return 0;
}




//获取时间和日期
int  ONVIF_GetSystemTimeAndDate(Remote_Device_Info *pDeviceInfo)
{
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] )
    {
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);

    char ServiceAddr[MAX_LEN] = {0};
    int l_Return = -1;
    bool IsUTC;

    struct _tds__GetSystemDateAndTime  GetSystemDateAndTime ;
    struct _tds__GetSystemDateAndTimeResponse GetSystemDateAndTimeResponse = {0};

    sprintf(ServiceAddr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);

    l_Return=  soap_call___tds__GetSystemDateAndTime(soap, ServiceAddr, NULL, &GetSystemDateAndTime, &GetSystemDateAndTimeResponse) ;
    //成功获取设备的日期和时间信息
    if(l_Return == SOAP_OK)
    {
        if(NULL != GetSystemDateAndTimeResponse.SystemDateAndTime)
        {
            if(NULL != GetSystemDateAndTimeResponse.SystemDateAndTime->UTCDateTime)
            {
                IsUTC = true;
                ONVIF_DBP("%d:%d:%d\r\n",GetSystemDateAndTimeResponse.SystemDateAndTime->UTCDateTime->Date->Year,GetSystemDateAndTimeResponse.SystemDateAndTime->UTCDateTime->Date->Month,GetSystemDateAndTimeResponse.SystemDateAndTime->UTCDateTime->Date->Day);
            }
            else
            {
                IsUTC = false;
            }
            ONVIF_DBP("#####获取设备日期及时间信息成功\r\n");
        }

    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    return l_Return ;
}




//权限认证
int ONVIF_SetAuthenticationInformation(struct soap * soap_overall ,const char * Username, const char * Password)
{
    int l_Return = 0 ;
    l_Return = soap_wsse_add_UsernameTokenDigest(soap_overall,Username,Username,Password);
    if(SOAP_OK != l_Return)
    {
        ONVIF_DBP("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$认证失败！$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
    }
    return l_Return ;
}


//设置系统日期和时间
int ONVIF_SetSystemDateAndTime()
{
    return SOAP_OK;
}


int ONVIF_DeleteRemoteDevice(Remote_Device_Info *pDeviceInfo)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip  )
    {
        return -1;
    }
    if ( strlen(pDeviceInfo->ip) < 1 )
    {
        return -1;
    }
    int index = 0;
    for ( index = 0; index < MAX_CAMERA; index++ )
    {
        if ( strncmp(g_onvifCameras.cameraIpInfo[index].ip, pDeviceInfo->ip, MAX_IP_LEN - 1 ) == 0 )
        {
            g_onvifCameras.cameraIpInfo[index].ip[0] = '\0';
            memset(&g_onvifCameras.onvif_info[index], 0, sizeof(ONVIF_INFO));
            memset(&g_onvifCameras.CameraEvents[index],0,sizeof(Onvif_Event_Item));
            memset(&g_onvifCameras.cameraIpInfo[index],0,sizeof(CameraIpInfo));
        }
    }
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return 1;
}









int ONVIF_AddRemoteDevice(unsigned int Channel ,Remote_Device_Info *pDeviceInfo)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip)
    {
        return -1;
    }
    if ( strlen(pDeviceInfo->ip) < 1 )
    {
        return -1;
    }
    if ( Channel >= MAX_CAMERA )
    {
        return -1;
    }
    if( strncmp(g_onvifCameras.cameraIpInfo[Channel].ip, pDeviceInfo->ip, MAX_IP_LEN - 1 ) != 0 ||
            strncmp(g_onvifCameras.cameraIpInfo[Channel].User, pDeviceInfo->userName, MAX_IP_LEN - 1) !=0 ||
            strncmp(g_onvifCameras.cameraIpInfo[Channel].Password, pDeviceInfo->password, MAX_IP_LEN - 1 ) !=0 )
    {
        ONVIF_DBP("===old ip=%s ;=====%s %d \n",g_onvifCameras.cameraIpInfo[Channel].ip);
        ONVIF_DBP( "===new ip=%s ;=====%s %d \n",pDeviceInfo->ip);
        strncpy(g_onvifCameras.cameraIpInfo[Channel].ip, pDeviceInfo->ip, MAX_IP_LEN - 1);
        strncpy(g_onvifCameras.cameraIpInfo[Channel].User, pDeviceInfo->userName, MAX_IP_LEN - 1);
        strncpy(g_onvifCameras.cameraIpInfo[Channel].Password, pDeviceInfo->password, MAX_IP_LEN - 1);
        g_onvifCameras.cameraIpInfo[Channel].port = pDeviceInfo->port;
    }
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return  Channel ;
}


int ONVIF_GetCameraIndex( const char *ip )
{
    ONVIF_DBP("################%s\n",ip);
    if (!ip)
    {
        return -1;
    }
    if ( strlen(ip) < 1 )
    {
        return -1;
    }
    int index = 0;
    for ( index = 0; index < MAX_CAMERA; index++ )
    {
        if ( strncmp(g_onvifCameras.cameraIpInfo[index].ip, ip, MAX_IP_LEN - 1 ) == 0 )
        {
            return index;
        }
    }
    ONVIF_DBP("################%s\n",ip);
    return -1;

}


int GetCapabilities(Remote_Device_Info *pDeviceInfo)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo ) {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);

    char ServiceAddr[MAX_LEN] ;

    //必须先设置设备的服务地址
    sprintf(ServiceAddr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);
    ONVIF_DBP("ServiceAddr =======%s\n",ServiceAddr);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tds__GetCapabilities *p_tds__GetCapabilities =(struct _tds__GetCapabilities *)soap_malloc(soap, sizeof(struct _tds__GetCapabilities));
    memset(p_tds__GetCapabilities, 0, sizeof(struct _tds__GetCapabilities));
    p_tds__GetCapabilities->__sizeCategory = 0;
    p_tds__GetCapabilities->Category = soap_malloc(soap, sizeof(enum tt__CapabilityCategory));
    p_tds__GetCapabilities->Category = tt__CapabilityCategory__All;

    struct _tds__GetCapabilitiesResponse *p_tds__GetCapabilitiesResponse =(struct _tds__GetCapabilitiesResponse *)soap_malloc(soap, sizeof(struct _tds__GetCapabilitiesResponse));;
    memset(p_tds__GetCapabilitiesResponse, 0, sizeof(struct _tds__GetCapabilitiesResponse));

    soap_call___tds__GetCapabilities(soap, ServiceAddr, NULL, p_tds__GetCapabilities, p_tds__GetCapabilitiesResponse);

    if (!soap->error)
    {
        int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
        if ( (-1 != index) && index < MAX_CAMERA )
        {
            memset(&g_onvifCameras.onvif_info[index].tdsCapabilities, 0, sizeof(TdsCapabilities));
            if ( p_tds__GetCapabilitiesResponse->Capabilities->Analytics )
            {

            }

            if ( p_tds__GetCapabilitiesResponse->Capabilities->Device)
            {
                g_onvifCameras.onvif_info[index].tdsCapabilities.hasDeviceCapabilities = 1;

                if ( p_tds__GetCapabilitiesResponse->Capabilities->Device->XAddr )
                {

                    strncpy(g_onvifCameras.onvif_info[index].tdsCapabilities.deviceCapabilities.XAddr,
                            p_tds__GetCapabilitiesResponse->Capabilities->Device->XAddr, MAX_URL_LEN - 1);
                    g_onvifCameras.onvif_info[index].tdsCapabilities.deviceCapabilities.XAddr[MAX_URL_LEN - 1] = '\0';
                    ONVIF_DBP(" device xaddr %s \n", p_tds__GetCapabilitiesResponse->Capabilities->Device->XAddr);
                }

#if 0

                if ( p_tds__GetCapabilitiesResponse->Capabilities->Device->IO->RelayOutputs )

                {
                }

#endif



                if( p_tds__GetCapabilitiesResponse->Capabilities->Device->Network )
                {
                }
                if ( p_tds__GetCapabilitiesResponse->Capabilities->Device->System ) {

                    p_tds__GetCapabilitiesResponse->Capabilities->Device->System->DiscoveryBye;
                    p_tds__GetCapabilitiesResponse->Capabilities->Device->System->DiscoveryResolve;
                    p_tds__GetCapabilitiesResponse->Capabilities->Device->System->FirmwareUpgrade;

                    unsigned int sizeSupportedVersions = p_tds__GetCapabilitiesResponse->Capabilities->Device->System->__sizeSupportedVersions;
                    g_onvifCameras.onvif_info[index].tdsCapabilities.deviceCapabilities.sizeOfVersion =
                            sizeSupportedVersions > MAX_ONVIF_VERSION_SUPPORT - 1 ? MAX_ONVIF_VERSION_SUPPORT - 1 : sizeSupportedVersions;
                    sizeSupportedVersions = g_onvifCameras.onvif_info[index].tdsCapabilities.deviceCapabilities.sizeOfVersion;

                    int k = 0;
                    while( k < sizeSupportedVersions ) {
                        // ONVIF_DBP(" onvif version %d.%d \n",
                        //         p_tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions[k].Major,
                        //         p_tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions[k].Minor);

                        g_onvifCameras.onvif_info[index].tdsCapabilities.deviceCapabilities.onvifVersion[k].major =
                                p_tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions[k].Major;

                        g_onvifCameras.onvif_info[index].tdsCapabilities.deviceCapabilities.onvifVersion[k].minor=
                                p_tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions[k].Minor;

                        k++;
                    }
                }

                if ( p_tds__GetCapabilitiesResponse->Capabilities->Events ) {

                    g_onvifCameras.onvif_info[index].tdsCapabilities.hasEventCapabilities = 1;

                    g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.WSPausableSubscriptionManagerInterfaceSupport
                            = p_tds__GetCapabilitiesResponse->Capabilities->Events->WSPausableSubscriptionManagerInterfaceSupport;

                    g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.WSPullPointSupport
                            = p_tds__GetCapabilitiesResponse->Capabilities->Events->WSPullPointSupport;

                    g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.WSSubscriptionPolicySupport
                            = p_tds__GetCapabilitiesResponse->Capabilities->Events->WSSubscriptionPolicySupport;

                    if ( p_tds__GetCapabilitiesResponse->Capabilities->Events->XAddr ) {
                        strncpy(g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.XAddr,
                                p_tds__GetCapabilitiesResponse->Capabilities->Events->XAddr, MAX_URL_LEN - 1);
                        g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.XAddr[MAX_URL_LEN - 1] = '\0';

                        //   ONVIF_DBP(" event xaddr %s \n", p_tds__GetCapabilitiesResponse->Capabilities->Events->XAddr );
                    }
                }
                if ( p_tds__GetCapabilitiesResponse->Capabilities->Imaging ) {

                    g_onvifCameras.onvif_info[index].tdsCapabilities.hasImagingCapabilities = 1;

                    if ( p_tds__GetCapabilitiesResponse->Capabilities->Imaging->XAddr ) {
                        strncpy(g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr,
                                p_tds__GetCapabilitiesResponse->Capabilities->Imaging->XAddr, MAX_URL_LEN - 1);

                        g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr[MAX_URL_LEN - 1] = '\0';
                        //  ONVIF_DBP(" imaging xaddr %s \n", p_tds__GetCapabilitiesResponse->Capabilities->Imaging->XAddr);
                    }
                }
                if ( p_tds__GetCapabilitiesResponse->Capabilities->Media ) {
                    g_onvifCameras.onvif_info[index].tdsCapabilities.hasMediaCapabilities = 1;
                    if ( p_tds__GetCapabilitiesResponse->Capabilities->Media->XAddr ) {
                        strncpy(g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr,
                                p_tds__GetCapabilitiesResponse->Capabilities->Media->XAddr, MAX_URL_LEN - 1);
                        g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr[MAX_URL_LEN - 1] = '\0';
                        ONVIF_DBP(" media xaddr %s \n", p_tds__GetCapabilitiesResponse->Capabilities->Media->XAddr );
                    }
                    if ( p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities ) {
                        if ( p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTPMulticast ) {
                            g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.StreamingCapabilities.RTPMulticast
                                    = *p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTPMulticast;
                            //   ONVIF_DBP(" streaming rtp multicast \n");
                        }

                        if ( p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORERTSP_USCORETCP ) {
                            g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.StreamingCapabilities.RTP_USCORERTSP_USCORETCP
                                    = *p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORERTSP_USCORETCP;

                            //   ONVIF_DBP(" streaming rtp RTP_USCORERTSP_USCORETCP \n");
                        }

                        if ( p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORETCP ) {
                            g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.StreamingCapabilities.RTP_USCORETCP
                                    = *p_tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORETCP;

                            //  ONVIF_DBP(" streaming rtp RTP_USCORETCP \n");
                        }
                    }
                }

                if ( p_tds__GetCapabilitiesResponse->Capabilities->PTZ ) {

                    g_onvifCameras.onvif_info[index].tdsCapabilities.hasPTZCapabilities = 1;
                    if ( p_tds__GetCapabilitiesResponse->Capabilities->PTZ->XAddr ) {
                        strncpy(g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr,
                                p_tds__GetCapabilitiesResponse->Capabilities->PTZ->XAddr, MAX_URL_LEN - 1);

                        g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr[MAX_URL_LEN - 1] = '\0';

                        // ONVIF_DBP(" ptz xaddr %s \n", p_tds__GetCapabilitiesResponse->Capabilities->PTZ->XAddr);
                    }
                }
            }
        }
    }

    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;

}



int ONVIF_GetDeviceInformation( Remote_Device_Info *pDeviceInfo )
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] )
    {
        return -1;
    }
    char ServiceAddr[MAX_LEN] ;
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);


    struct _tds__GetDeviceInformation tds__GetDeviceInformation;
    struct _tds__GetDeviceInformationResponse p_tds__GetDeviceInformationResponse = {0};

    //必须先设置设备的服务地址
    sprintf(ServiceAddr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }
    soap_call___tds__GetDeviceInformation(soap, ServiceAddr, NULL, &tds__GetDeviceInformation, &p_tds__GetDeviceInformationResponse);

    if ( ! soap->error )
    {
        int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
        if ( (-1 != index) && index < MAX_CAMERA )
        {
            memset(&g_onvifCameras.onvif_info[index].Manufacturer, 0, sizeof(char)*MAX_STRING_LENGTH);
            memset(&g_onvifCameras.onvif_info[index].FirmwareVersion, 0, sizeof(char)*MAX_STRING_LENGTH);
            memset(&g_onvifCameras.onvif_info[index].SerialNumber, 0, sizeof(char)*MAX_STRING_LENGTH);
            memset(&g_onvifCameras.onvif_info[index].HardwareId, 0, sizeof(char)*MAX_STRING_LENGTH);
            if (p_tds__GetDeviceInformationResponse.Manufacturer )
            {
                strncpy(g_onvifCameras.onvif_info[index].Manufacturer,
                        p_tds__GetDeviceInformationResponse.Manufacturer, MAX_STRING_LENGTH - 1);
                g_onvifCameras.onvif_info[index].Manufacturer[MAX_STRING_LENGTH - 1] = '\0';
                // ONVIF_DBP("Manufacturer  %s \n", p_tds__GetDeviceInformationResponse.Manufacturer);
            }
            if (p_tds__GetDeviceInformationResponse.FirmwareVersion )
            {
                strncpy(g_onvifCameras.onvif_info[index].FirmwareVersion,
                        p_tds__GetDeviceInformationResponse.FirmwareVersion, MAX_STRING_LENGTH - 1);
                g_onvifCameras.onvif_info[index].FirmwareVersion[MAX_STRING_LENGTH - 1] = '\0';
                // ONVIF_DBP("FirmwareVersion  %s \n", p_tds__GetDeviceInformationResponse.FirmwareVersion );
            }
            if (p_tds__GetDeviceInformationResponse.SerialNumber )
            {

                strncpy(g_onvifCameras.onvif_info[index].SerialNumber,
                        p_tds__GetDeviceInformationResponse.SerialNumber, MAX_STRING_LENGTH - 1);
                g_onvifCameras.onvif_info[index].SerialNumber[MAX_STRING_LENGTH - 1] = '\0';
                // ONVIF_DBP("SerialNumber  %s \n", p_tds__GetDeviceInformationResponse.SerialNumber );
            }
            if (p_tds__GetDeviceInformationResponse.HardwareId )
            {
                strncpy(g_onvifCameras.onvif_info[index].HardwareId,
                        p_tds__GetDeviceInformationResponse.HardwareId, MAX_STRING_LENGTH - 1);
                g_onvifCameras.onvif_info[index].HardwareId[MAX_STRING_LENGTH - 1] = '\0';
                // ONVIF_DBP("HardwareId  %s \n", p_tds__GetDeviceInformationResponse.HardwareId );
            }
        }
    }
    if (soap->error)
    {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;
}

int GetProfiles(Remote_Device_Info *pDeviceInfo)
{

    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo ) {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( ( index < 0 ) || index > MAX_CAMERA -1 )
    {
        ONVIF_DBP(" ###############################没有IP地址 index = %d \n", index );
        return -1;
    }
    ONVIF_DBP("!!!!!!!!!!!!!!!!!!!!!!!%s",g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr);
    char ServiceAddr[MAX_LEN] ;
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);


    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _trt__GetProfiles trt__GetProfiles;

    struct _trt__GetProfilesResponse *p_trt__GetProfilesResponse = (struct _trt__GetProfilesResponse *)soap_malloc(soap, sizeof(struct _trt__GetProfilesResponse));;
    memset(p_trt__GetProfilesResponse, 0, sizeof(struct _trt__GetProfilesResponse));
    if(!isalnum(g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr[0]))
    {
        sprintf(ServiceAddr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);
        soap_call___trt__GetProfiles(soap, ServiceAddr, NULL, &trt__GetProfiles, p_trt__GetProfilesResponse);
        ONVIF_DBP(" &&&&&&&&&&&&&媒体服务地址为空 \n");
    }
    else
    {
        soap_call___trt__GetProfiles(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL, &trt__GetProfiles, p_trt__GetProfilesResponse);
    }

    if ( !soap->error )
    {
        // int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
        if ( (-1 != index) && index < MAX_CAMERA )
        {
            g_onvifCameras.onvif_info[index].profileSize = p_trt__GetProfilesResponse->__sizeProfiles;
            memset(g_onvifCameras.onvif_info[index].Profiles, 0, g_onvifCameras.onvif_info[index].profileSize);
            ONVIF_DBP(" profiles size %d \n", p_trt__GetProfilesResponse->__sizeProfiles);
            int profileIndex = 0;
            for ( profileIndex = 0; profileIndex < p_trt__GetProfilesResponse->__sizeProfiles; profileIndex++ )
            {
                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].Name )
                {
                    strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].profilename,
                            p_trt__GetProfilesResponse->Profiles[profileIndex].Name, MAX_PROF_TOKEN - 1 );
                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].profilename[MAX_PROF_TOKEN - 1] = '\0';

                    ONVIF_DBP("profile name %s \n", p_trt__GetProfilesResponse->Profiles[profileIndex].Name );
                }

                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].token ) {
                    strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].profiletoken,
                            p_trt__GetProfilesResponse->Profiles[profileIndex].token, MAX_PROF_TOKEN - 1 );
                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].profiletoken[MAX_PROF_TOKEN - 1] = '\0';

                    ONVIF_DBP("profile token %s \n", p_trt__GetProfilesResponse->Profiles[profileIndex].token );
                }

                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration ) {
                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->SourceToken ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AVSC.Vsourcetoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->SourceToken,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AVSC.Vsourcetoken[MAX_PROF_TOKEN - 1] = '\0';

                        //       ONVIF_DBP( " VideoSourceToken %s \n",
                        //                 p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->SourceToken);
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->Name ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AVSC.Vname,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->Name,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AVSC.Vname[MAX_PROF_TOKEN - 1] = '\0';
                        //       ONVIF_DBP( " VideoSourceName %s \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->Name);
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->token  ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AVSC.Vtoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->token,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AVSC.Vtoken[MAX_PROF_TOKEN - 1] = '\0';
                        //       ONVIF_DBP( " VideoSourcetoken %s \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoSourceConfiguration->token);
                    }
                }

                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration ) {

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Name ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.VEname,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Name,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.VEname[MAX_PROF_TOKEN - 1] = '\0';

                        //       ONVIF_DBP("videoEncoderName %s \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Name);
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->token ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.VEtoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->token,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.VEtoken[MAX_PROF_TOKEN - 1] = '\0';

                        // ONVIF_DBP(stderr,"videoEncodertoken %s \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->token);
                    }

                    //   ONVIF_DBP("Encoding %d \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Encoding );


                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Resolution ) {

                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.Rwidth =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Resolution->Width;

                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.Rheight =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Resolution->Height;

                        //       ONVIF_DBP(" width %d height %d \n",
                        //                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Resolution->Width,
                        //                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Resolution->Height );
                    }

                    //编码类型
                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.Vencoder = p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Encoding;
                    ONVIF_DBP("AESC.Vencoder %d \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Encoding );
                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->H264 )
                    {
                        //     ONVIF_DBP("h264 govlenght %d \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->H264->GovLength );
                        //     ONVIF_DBP("h264 profile %d \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->H264->H264Profile );
                        



                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.H264govlength =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->H264->GovLength;

                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.H264profile =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->H264->H264Profile;
                    }


                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.VEquality =
                            p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Quality;


                    //   ONVIF_DBP("quality %f \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->Quality );

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl ) {

                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.frameratelimit =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl->FrameRateLimit;

                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.encodinginterval =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl->EncodingInterval;

                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AESC.bitratelimit =
                                p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl->BitrateLimit;

                        //    ONVIF_DBP(" framelimit %d encodingInterval %d bitratelimit %d \n",
                        //              p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl->FrameRateLimit,
                        //               p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl->EncodingInterval,
                        //              p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->RateControl->BitrateLimit );

                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->SessionTimeout ) {
                        //    ONVIF_DBP("sesion timeout %d \n", p_trt__GetProfilesResponse->Profiles[profileIndex].VideoEncoderConfiguration->SessionTimeout);
                    }

                }
#if 0

                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration )
                {
                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->Name ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AASC.Aname,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->Name,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AASC.Aname[MAX_PROF_TOKEN - 1] = '\0';
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->token ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AASC.Atoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->token,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AASC.Atoken[MAX_PROF_TOKEN - 1] = '\0';

                    }
                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->SourceToken ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AASC.Asourcetoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->SourceToken,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AASC.Asourcetoken[MAX_PROF_TOKEN - 1] = '\0';

                    }

                }

                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration )
                {

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->Name ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.AEname,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->Name,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.AEname[MAX_PROF_TOKEN - 1] = '\0';

                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->token ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.AEtoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].AudioSourceConfiguration->token,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.AEtoken[MAX_PROF_TOKEN - 1] = '\0';

                    }


                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.AEencoding =
                            p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->Encoding;

                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.samplerate =
                            p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->SampleRate;

                    g_onvifCameras.onvif_info[index].Profiles[profileIndex].AAEC.bitrate =
                            p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->Bitrate;

                    //  ONVIF_DBP("audio encoding %d sample %d bitrate %d \n",
                    //         p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->Encoding,
                    //         p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->SampleRate,
                    //         p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->Bitrate );

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->SessionTimeout ) {
                        //    ONVIF_DBP("audio encoder session timeout %d \n",
                        //              p_trt__GetProfilesResponse->Profiles[profileIndex].AudioEncoderConfiguration->SessionTimeout);
                    }

                }
#endif

                if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration ) {

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->token ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZtoken ,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->token,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZtoken[MAX_PROF_TOKEN - 1] = '\0';
                    }


                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->Name ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZname,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->Name,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZname[MAX_PROF_TOKEN - 1] = '\0';
                    }
#if 0
                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->NodeToken ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZnodetoken,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->NodeToken,
                                MAX_PROF_TOKEN - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZnodetoken[MAX_PROF_TOKEN - 1] = '\0';
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultAbsolutePantTiltPositionSpace ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultAbsolutePantTiltPositionSpace,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultAbsolutePantTiltPositionSpace,
                                MAX_STRING_LENGTH - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultAbsolutePantTiltPositionSpace[MAX_STRING_LENGTH - 1] = '\0';
                        //    ONVIF_DBP("DefaultAbsolutePantTiltPositionSpace %s \n",
                        //              p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultAbsolutePantTiltPositionSpace );
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultAbsoluteZoomPositionSpace ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultAbsoluteZoomPositionSpace,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultAbsoluteZoomPositionSpace,
                                MAX_STRING_LENGTH - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultAbsoluteZoomPositionSpace[MAX_STRING_LENGTH - 1] = '\0';


                        //    ONVIF_DBP("DefaultAbsoluteZoomPositionSpace %s \n",
                        //             p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultAbsoluteZoomPositionSpace );
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultContinuousPanTiltVelocitySpace ) {
                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultContinuousPanTiltVelocitySpace,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultContinuousPanTiltVelocitySpace,
                                MAX_STRING_LENGTH - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultAbsoluteZoomPositionSpace[MAX_STRING_LENGTH - 1] = '\0';

                        //    ONVIF_DBP("DefaultContinuousPanTiltVelocitySpace %s \n",
                        //             p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultContinuousPanTiltVelocitySpace );
                    }

                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultContinuousZoomVelocitySpace ) {

                        strncpy(g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultContinuousZoomVelocitySpace,
                                p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultContinuousZoomVelocitySpace,
                                MAX_STRING_LENGTH - 1);
                        g_onvifCameras.onvif_info[index].Profiles[profileIndex].DefaultContinuousZoomVelocitySpace[MAX_STRING_LENGTH - 1] = '\0';


                        //    ONVIF_DBP("DefaultContinuousZoomVelocitySpace %s \n",
                        //             p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultContinuousZoomVelocitySpace );
                    }

#endif
                    if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed ) {

                        if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt ) {

                            if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt->space ) {
                                //         ONVIF_DBP("panTileSpace %s \n",
                                //                   p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt->space);
                            }

                            g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZspeedx =
                                    p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt->x;

                            g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZspeedy =
                                    p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt->y;

                            //     ONVIF_DBP("PTZspeedx %f ,,PTZspeedy %f \n",
                            //               p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt->x,
                            //               p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->PanTilt->y );
                        }

                        if ( p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->Zoom ) {
                            if (p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->Zoom->space ) {
                                //        ONVIF_DBP("zoom space %s \n",
                                //                 p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->Zoom->space);
                            }

                            g_onvifCameras.onvif_info[index].Profiles[profileIndex].PTZzoom =
                                    p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->Zoom->x;

                            //     ONVIF_DBP("zoom x %f \n", p_trt__GetProfilesResponse->Profiles[profileIndex].PTZConfiguration->DefaultPTZSpeed->Zoom->x);
                        }

                    }
                }

            }
        }

    }

    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);

    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;

}


int ONVIF_GetProfiles(Remote_Device_Info *pDeviceInfo, Onvif_Profiles *pGetProfilesRespone)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !pGetProfilesRespone ) {
        return -1;
    }
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] )
    {
        return -1;
    }
    int index = 0;
    int ret = 0;
    pthread_mutex_lock(&onvif_data_mutex);
    ONVIF_DBP("@@@@@@@@@@@@@@@@@@@ %s got mutex \n",pDeviceInfo->ip);
    index = ONVIF_GetCameraIndex(pDeviceInfo);
    if ( index < 0 )
    {
        pthread_mutex_unlock(&onvif_data_mutex);
        return -1;
    }
    int result  = GetCapabilities(pDeviceInfo);
    if ( 1 != result )
    {
        pthread_mutex_unlock(&onvif_data_mutex);
        return -1;
    }
    // ONVIF_GetDeviceInformation(pDeviceInfo);
    result = GetProfiles(pDeviceInfo);
    if ( 1 != result )
    {
        pthread_mutex_unlock(&onvif_data_mutex);
        return -1;
    }
    pthread_mutex_unlock(&onvif_data_mutex);
    pGetProfilesRespone->sizeOfProfiles = g_onvifCameras.onvif_info[index].profileSize;
    int k = 0;
    for ( k = 0; k < pGetProfilesRespone->sizeOfProfiles; k++ )
    {

        if (g_onvifCameras.onvif_info[index].Profiles[k].profilename[0] ) {
            strncpy(pGetProfilesRespone->Onvif_Profiles[k].profieName,
                    g_onvifCameras.onvif_info[index].Profiles[k].profilename, MAX_LEN - 1);
            pGetProfilesRespone->Onvif_Profiles[k].profieName[MAX_LEN - 1] = '\0';
        }

        if ( g_onvifCameras.onvif_info[index].Profiles[k].profiletoken[0] ) {
            strncpy(pGetProfilesRespone->Onvif_Profiles[k].profileToken,
                    g_onvifCameras.onvif_info[index].Profiles[k].profiletoken, MAX_LEN - 1);
            pGetProfilesRespone->Onvif_Profiles[k].profileToken[MAX_LEN - 1] = '\0';

        }

        strncpy(pGetProfilesRespone->Onvif_Profiles[k].videoConfig.Name,
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.VEname, MAX_LEN - 1);
        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.Name[MAX_LEN - 1] = '\0';

        strncpy(pGetProfilesRespone->Onvif_Profiles[k].videoConfig.token,
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.VEtoken, MAX_LEN - 1);
        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.token[MAX_LEN - 1] = '\0';

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.videoEncoding
                = g_onvifCameras.onvif_info[index].Profiles[k].AESC.Vencoder;


        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.width =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.Rwidth;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.height =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.Rheight;

        int encoding = g_onvifCameras.onvif_info[index].Profiles[k].AESC.Vencoder;

        if ( 2 == encoding )
        { // h264
            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.h264.GovLength =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.H264govlength;

            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.h264.H264Profile =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.H264profile;
        }
        if ( 1 == encoding )
        {
            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.mpeg4.GovLength =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.Mpeggovlength;

            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.mpeg4.Mpeg4Profile =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.Mpegprofile;
        }

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.FrameRateLimit =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.frameratelimit;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.BitrateLimit =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.bitratelimit;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.EncodingInterval =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.encodinginterval;

        strncpy(pGetProfilesRespone->Onvif_Profiles[k].videoSourceToken,
                g_onvifCameras.onvif_info[index].Profiles[k].AVSC.Vsourcetoken, MAX_LEN - 1);
        pGetProfilesRespone->Onvif_Profiles[k].videoSourceToken[MAX_LEN - 1] = '\0';

        // PTZ
        strncpy(pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.token,
                g_onvifCameras.onvif_info[index].Profiles[k].PTZtoken,
                sizeof(pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.token) - 1 );

        pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.DefaultPanTiltSpeedX =
                g_onvifCameras.onvif_info[index].Profiles[k].PTZspeedx;

        pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.DefaultPanTiltSpeedY =
                g_onvifCameras.onvif_info[index].Profiles[k].PTZspeedy;

        pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.DefaultZoomSpeedX  =
                g_onvifCameras.onvif_info[index].Profiles[k].PTZzoom;

    }
    //pthread_mutex_unlock(&onvif_data_mutex);
    //Onvif_Ptz_Config ptzConfig;
    //memset(&ptzConfig, 0, sizeof(Onvif_Ptz_Config));
    //ONVIF_PtzGetConfiguration(pDeviceInfo, &ptzConfig);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    //memcpy(&g_onvifCameras.onvif_info[index].Profiles[0].ptzConfig, &ptzConfig, sizeof(ptzConfig));
    return pGetProfilesRespone->sizeOfProfiles ? 1 : -1;

}


int ONVIF_GetStreamUri( Remote_Device_Info *pDeviceInfo, const  char *profileToken, char *urlBuf)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] )
    {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( (index < 0) || index > MAX_CAMERA -1 )
    {
        ONVIF_DBP(" &&&&&&&&&&&&没有IP地址\n");
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&媒体服务地址为空 \n");
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);
#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }
    char ServiceAddr[MAX_LEN];
    struct tt__Transport Transport;
    Transport.Protocol = tt__TransportProtocol__UDP;
    Transport.Tunnel=NULL;
    struct tt__StreamSetup  StreamSetup;
    StreamSetup.Transport = (struct tt__Transport *)soap_malloc(soap, sizeof( struct tt__Transport));
    memset(StreamSetup.Transport, 0, sizeof(struct tt__Transport));
    StreamSetup.Stream = tt__StreamType__RTP_Unicast;
    StreamSetup.Transport = &Transport;
    StreamSetup.__size = 0;
    StreamSetup.__any= NULL;
    StreamSetup.__anyAttribute= NULL;


    struct _trt__GetStreamUri *p_trt__GetStreamUri = (struct _trt__GetStreamUri *)soap_malloc(soap, sizeof(struct _trt__GetStreamUri));
    memset(p_trt__GetStreamUri, 0, sizeof(struct _trt__GetStreamUri));

    p_trt__GetStreamUri->StreamSetup  = &StreamSetup;
    p_trt__GetStreamUri->ProfileToken = (char*)soap_malloc(soap, 128);
    memset(p_trt__GetStreamUri->ProfileToken, 0, 128);

    if ( profileToken )
    {
        strncpy(p_trt__GetStreamUri->ProfileToken, profileToken, 127);
    }

    struct _trt__GetStreamUriResponse *p_trt__GetStreamUriResponse =
            (struct _trt__GetStreamUriResponse *)soap_malloc(soap, sizeof(struct _trt__GetStreamUriResponse));

            memset(p_trt__GetStreamUriResponse, 0, sizeof(struct _trt__GetStreamUriResponse));

            if(!isalnum(g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr[0]))
            {
                sprintf(ServiceAddr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);
                soap_call___trt__GetStreamUri(soap, ServiceAddr, NULL, p_trt__GetStreamUri, p_trt__GetStreamUriResponse);
                ONVIF_DBP(" &&&&&&&&&&&&&媒体服务地址为空 \n");
            }
            else
            {
                soap_call___trt__GetStreamUri(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL, p_trt__GetStreamUri, p_trt__GetStreamUriResponse);
            }
            if ( !soap->error )
            {

                ONVIF_DBP("&&&&&&&&&&&&&&&&&&&&&get Uri success : %s\nTimeout %d\nInvalidAfterConnect %d\nInvalidAfterReboot %d \n",
                          p_trt__GetStreamUriResponse->MediaUri->Uri, p_trt__GetStreamUriResponse->MediaUri->Timeout,
                          p_trt__GetStreamUriResponse->MediaUri->InvalidAfterConnect,
                          p_trt__GetStreamUriResponse->MediaUri->InvalidAfterReboot);

                strcpy(urlBuf, p_trt__GetStreamUriResponse->MediaUri->Uri);
            }

            if (soap->error)
            {
                ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
            }
            soap_destroy(soap);
            soap_end(soap);
            soap_done(soap);
            soap->error = (soap->error == 0 ? 1 : -1);
            ONVIF_DBP("################%s\n",pDeviceInfo->ip);
            return soap->error;
}


int ONVIF_GetProfilesFromCache( Remote_Device_Info *pDeviceInfo, Onvif_Profiles *pGetProfilesRespone )
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !pGetProfilesRespone) {
        ONVIF_DBP("################%s\n",pDeviceInfo->ip);
        return -1;
    }
    int index = 0;
    int ret = 0;
    index = ONVIF_GetCameraIndex(pDeviceInfo);
    if ( index < 0 || index > MAX_CAMERA - 1)
    {
        ONVIF_DBP("################%s\n",pDeviceInfo->ip);
        return -1;
    }
    pGetProfilesRespone->sizeOfProfiles = g_onvifCameras.onvif_info[index].profileSize;

    int k = 0;
    for ( k = 0; k < pGetProfilesRespone->sizeOfProfiles; k++ ) {


        if ( g_onvifCameras.onvif_info[index].Profiles[k].profilename[0] ) {

            strncpy(pGetProfilesRespone->Onvif_Profiles[k].profieName,
                    g_onvifCameras.onvif_info[index].Profiles[k].profilename, MAX_LEN - 1);
            pGetProfilesRespone->Onvif_Profiles[k].profieName[MAX_LEN - 1] = '\0';
        }

        if ( g_onvifCameras.onvif_info[index].Profiles[k].profiletoken[0] ) {
            strncpy(pGetProfilesRespone->Onvif_Profiles[k].profileToken,
                    g_onvifCameras.onvif_info[index].Profiles[k].profiletoken, MAX_LEN - 1);
            pGetProfilesRespone->Onvif_Profiles[k].profileToken[MAX_LEN - 1] = '\0';
        }


        strncpy(pGetProfilesRespone->Onvif_Profiles[k].videoConfig.Name,
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.VEname, MAX_LEN - 1);
        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.Name[MAX_LEN - 1] = '\0';

        strncpy(pGetProfilesRespone->Onvif_Profiles[k].videoConfig.token,
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.VEtoken, MAX_LEN - 1);
        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.token[MAX_LEN - 1] = '\0';

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.videoEncoding
                = g_onvifCameras.onvif_info[index].Profiles[k].AESC.Vencoder;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.width =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.Rwidth;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.height =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.Rheight;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.Quality =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.VEquality;

        int encoding = g_onvifCameras.onvif_info[index].Profiles[k].AESC.Vencoder;

        if ( 2 == encoding ) { // h264
            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.h264.GovLength =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.H264govlength;

            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.h264.H264Profile =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.H264profile;

        }

        if ( 1 == encoding ) {

            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.mpeg4.GovLength =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.Mpeggovlength;

            pGetProfilesRespone->Onvif_Profiles[k].videoConfig.mpeg4.Mpeg4Profile =
                    g_onvifCameras.onvif_info[index].Profiles[k].AESC.Mpegprofile;
        }

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.FrameRateLimit =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.frameratelimit;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.BitrateLimit =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.bitratelimit;

        pGetProfilesRespone->Onvif_Profiles[k].videoConfig.EncodingInterval =
                g_onvifCameras.onvif_info[index].Profiles[k].AESC.encodinginterval;

        strncpy(pGetProfilesRespone->Onvif_Profiles[k].videoSourceToken,
                g_onvifCameras.onvif_info[index].Profiles[k].AVSC.Vsourcetoken, MAX_LEN - 1);
        pGetProfilesRespone->Onvif_Profiles[k].videoSourceToken[MAX_LEN - 1] = '\0';


        // PTZ
        strncpy(pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.token,
                g_onvifCameras.onvif_info[index].Profiles[k].PTZtoken,
                sizeof(pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.token) - 1 );

        pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.DefaultPanTiltSpeedX =
                g_onvifCameras.onvif_info[index].Profiles[k].PTZspeedx;

        pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.DefaultPanTiltSpeedY =
                g_onvifCameras.onvif_info[index].Profiles[k].PTZspeedy;

        pGetProfilesRespone->Onvif_Profiles[k].ptzConfig.DefaultZoomSpeedX  =
                g_onvifCameras.onvif_info[index].Profiles[k].PTZzoom;

    }
    return 1;
}


int ONVIF_SetTimeOut(unsigned int ms)
{
    g_onvif_time_out = ms;
}


int ONVIF_SetDisplayNum(unsigned int num)
{
#if 0
    MaxCamera = num;
    if( g_onvifCameras.cameraIpInfo==NULL)
    {
        g_onvifCameras.cameraIpInfo=  (CameraIpInfo *) malloc(MaxCamera*sizeof(CameraIpInfo));
        fprintf(stderr,"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@g_onvifCameras.cameraIpInfo %d byte\n",MaxCamera*sizeof(CameraIpInfo));
        if(g_onvifCameras.cameraIpInfo==NULL)
        {
            ONVIF_DBP("分配空间失败");
            return -1;
        }
    }
    if( g_onvifCameras.onvif_info==NULL)
    {
        fprintf(stderr,"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@g_onvifCameras.ONVIF_INFO %d byte\n",MaxCamera*sizeof(ONVIF_INFO));
        g_onvifCameras.onvif_info=(ONVIF_INFO *) malloc(MaxCamera*sizeof(ONVIF_INFO));
        if(g_onvifCameras.onvif_info==NULL)
        {
            ONVIF_DBP("分配空间失败");
            return -1;
        }
    }
    if( g_onvifCameras.CameraEvents==NULL)
    {
        fprintf(stderr,"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@g_onvifCameras.Onvif_Event_Item %d byte\n",MaxCamera*sizeof(Onvif_Event_Item));
        g_onvifCameras.CameraEvents=(Onvif_Event_Item *) malloc(MaxCamera*sizeof(Onvif_Event_Item));
        if(g_onvifCameras.CameraEvents==NULL)
        {
            ONVIF_DBP("分配空间失败");
            return -1;
        }
    }
#endif
    return 0;


}



//获取音频编码配置参数
int GetAudioEncoderConfigurationOptions( Remote_Device_Info *pDeviceInfo, const char* ProfileToekn, const char* ConfigurationToken )
{
    if ( !pDeviceInfo ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&媒体服务地址为空 \n");
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif
    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _trt__GetAudioEncoderConfigurationOptions p_trt__GetAudioEncoderConfigurationOptions ;
    struct _trt__GetAudioEncoderConfigurationOptionsResponse p_trt__GetAudioEncoderConfigurationOptionsResponse = {0};

    soap_call___trt__GetAudioEncoderConfigurationOptions(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL,
                                                         &p_trt__GetAudioEncoderConfigurationOptions, &p_trt__GetAudioEncoderConfigurationOptionsResponse );
    if (!soap->error)
    {
        /********暂时不保存音频参数****************/
        ONVIF_DBP("获取音频参数成功\n");
    }
    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }

    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);

    return soap->error;

}


//获取视频配置信息（内部接口）
int GetVideoEncoderConfigurationOptions( Remote_Device_Info *pDeviceInfo, const char* ProfileToekn, const char* ConfigurationToken  )
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] )
    {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&媒体服务地址为空 \n");
        return -1;
    }
    int sizeResolutionsAvailable = 0;
    int k = 0;

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;

#endif
    soap_set_namespaces(soap, namespaces);
    soap_header(soap);


    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    struct _trt__GetVideoEncoderConfigurationOptions *p_trt__GetVideoEncoderConfigurationOptions =
            (struct _trt__GetVideoEncoderConfigurationOptions *)soap_malloc(soap, sizeof( struct _trt__GetVideoEncoderConfigurationOptions ));

            p_trt__GetVideoEncoderConfigurationOptions->ProfileToken = (char*)soap_malloc(soap, 128);
            memset(p_trt__GetVideoEncoderConfigurationOptions->ProfileToken, 0, 128);
            p_trt__GetVideoEncoderConfigurationOptions->ConfigurationToken = (char*)soap_malloc(soap, 128);
            memset(p_trt__GetVideoEncoderConfigurationOptions->ConfigurationToken, 0, 128);

            if ( ProfileToekn ) {
                strncpy(p_trt__GetVideoEncoderConfigurationOptions->ProfileToken, ProfileToekn, MAX_PROF_TOKEN - 1);
            }

            if ( ConfigurationToken ) {
                strncpy(p_trt__GetVideoEncoderConfigurationOptions->ConfigurationToken, ConfigurationToken, MAX_PROF_TOKEN - 1 );
            }

            struct _trt__GetVideoEncoderConfigurationOptionsResponse *p_trt__GetVideoEncoderConfigurationOptionsResponse =
                    soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse));
            memset(p_trt__GetVideoEncoderConfigurationOptionsResponse, 0, sizeof( struct _trt__GetVideoEncoderConfigurationOptionsResponse ));

            soap_call___trt__GetVideoEncoderConfigurationOptions(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL,
                                                                 p_trt__GetVideoEncoderConfigurationOptions, p_trt__GetVideoEncoderConfigurationOptionsResponse );
            ONVIF_DBP("################%s\n",pDeviceInfo->ip);
            if (!soap->error) {

                if ( (-1 != index) && index < MAX_CAMERA )
                {
                    memset(&g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions, 0, sizeof(VideoEncoderConfigurationOptions));
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.QualityRange.Min =
                            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->QualityRange->Min;

                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.QualityRange.Max =
                            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->QualityRange->Max;

                    if ( p_trt__GetVideoEncoderConfigurationOptionsResponse->Options )
                    {

                        if ( p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264 ) {
                            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasH264 = 1;

                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->EncodingIntervalRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.EncodingIntervalRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->EncodingIntervalRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.EncodingIntervalRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->EncodingIntervalRange->Min;

                            }
                            ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->FrameRateRange )
                            {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.FrameRateRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->FrameRateRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.FrameRateRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->FrameRateRange->Min;
                            }
#if 0
                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->Extension->H264->BitrateRange )
                            {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.BitrateRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->Extension->H264->BitrateRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.BitrateRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->Extension->H264->BitrateRange->Min;
                            }
#endif
                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->GovLengthRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.GovLengthRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->GovLengthRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.GovLengthRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->GovLengthRange->Min;
                            }

                            sizeResolutionsAvailable = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeResolutionsAvailable;


                            if ( sizeResolutionsAvailable > 0 ) {

                                sizeResolutionsAvailable = sizeResolutionsAvailable > MAX_RESOLUTIONS_AVAILABLE - 1 ?
                                            MAX_RESOLUTIONS_AVAILABLE - 1 : sizeResolutionsAvailable;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.__sizeResolutionsAvailable
                                        = sizeResolutionsAvailable;

                                for (k = 0; k < sizeResolutionsAvailable; k++)
                                {
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Width
                                            = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[k].Width;
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Height
                                            = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[k].Height;

                                }

                            }

                            int sizeH264Profiles = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeH264ProfilesSupported;

                            if ( sizeH264Profiles > 0  ) {
                                sizeH264Profiles = sizeH264Profiles > MAX_H264_PROFILES ? MAX_H264_PROFILES - 1 : sizeH264Profiles;
                                for ( k = 0; k < sizeH264Profiles; k++) {
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.H264ProfilesSupported[k] =
                                            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->H264ProfilesSupported[k];
                                }
                            }


                        }
#if 0

                        if ( p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG )
                        {

                            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasJPEG = 1;

                            sizeResolutionsAvailable = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->__sizeResolutionsAvailable;

                            if ( sizeResolutionsAvailable > 0) {

                                sizeResolutionsAvailable = sizeResolutionsAvailable > MAX_RESOLUTIONS_AVAILABLE - 1 ?
                                            MAX_RESOLUTIONS_AVAILABLE - 1 : sizeResolutionsAvailable;

                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.__sizeResolutionsAvailable =
                                        sizeResolutionsAvailable;

                                for (k = 0; k < sizeResolutionsAvailable; k++)
                                {
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.ResolutionsAvailable[k].Width
                                            = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[k].Width;
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.ResolutionsAvailable[k].Height
                                            = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[k].Height;
                                }

                            }

                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.FrameRateRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.FrameRateRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange->Min;

                            }

                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.EncodingIntervalRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.EncodingIntervalRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange->Min;

                            }

                        }


                        if ( p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4 ) {
                            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasMpeg4 = 1;

                            sizeResolutionsAvailable = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->__sizeResolutionsAvailable;

                            if ( sizeResolutionsAvailable > 0  ) {

                                sizeResolutionsAvailable = sizeResolutionsAvailable > MAX_RESOLUTIONS_AVAILABLE - 1 ?
                                            MAX_RESOLUTIONS_AVAILABLE - 1 : sizeResolutionsAvailable;

                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.__sizeResolutionsAvailable =
                                        sizeResolutionsAvailable;

                                for (k = 0; k < sizeResolutionsAvailable; k++)
                                {
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.ResolutionsAvailable[k].Width
                                            = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->ResolutionsAvailable[k].Width;
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.ResolutionsAvailable[k].Height
                                            = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->ResolutionsAvailable[k].Height;
                                }
                            }


                            int sizeMp4Profiles = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->__sizeMpeg4ProfilesSupported;

                            if ( sizeMp4Profiles > 0  ) {
                                sizeMp4Profiles = sizeMp4Profiles > MAX_H264_PROFILES ? MAX_H264_PROFILES - 1 : sizeMp4Profiles;
                                for ( k = 0; k < sizeMp4Profiles; k++) {
                                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.Mpeg4ProfilesSupported[k] =
                                            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->Mpeg4ProfilesSupported[k];

                                }
                            }


                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->GovLengthRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.GovLengthRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->GovLengthRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.GovLengthRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->GovLengthRange->Min;
                            }

                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->FrameRateRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.FrameRateRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->FrameRateRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.FrameRateRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->FrameRateRange->Min;
                            }

                            if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->EncodingIntervalRange ) {
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.EncodingIntervalRange.Max =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->EncodingIntervalRange->Max;
                                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.EncodingIntervalRange.Min =
                                        p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->EncodingIntervalRange->Min;
                            }
                        }

#endif

                    }

                }
            }


            if (soap->error) {
                ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
            }
            soap_destroy(soap);
            soap_end(soap);
            soap_done(soap);

            soap->error = (soap->error == 0 ? 1 : -1);
            ONVIF_DBP("################%s\n",pDeviceInfo->ip);
            return soap->error;

}





#if 0
int ONVIF_GetVideoEncoderConfigurationOptions( Remote_Device_Info *pDeviceInfo, const char* ProfileToekn, const char* ConfigurationToken)
{


    sizeResolutionsAvailable = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeResolutionsAvailable;


    if ( sizeResolutionsAvailable > 0 ) {

        sizeResolutionsAvailable = sizeResolutionsAvailable > MAX_RESOLUTIONS_AVAILABLE - 1 ?
                    MAX_RESOLUTIONS_AVAILABLE - 1 : sizeResolutionsAvailable;
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.__sizeResolutionsAvailable
                = sizeResolutionsAvailable;

        for (k = 0; k < sizeResolutionsAvailable; k++)
        {
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Width
                    = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[k].Width;
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Height
                    = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[k].Height;

        }

    }




    int sizeH264Profiles = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeH264ProfilesSupported;

    if ( sizeH264Profiles > 0  ) {
        sizeH264Profiles = sizeH264Profiles > MAX_H264_PROFILES ? MAX_H264_PROFILES - 1 : sizeH264Profiles;
        for ( k = 0; k < sizeH264Profiles; k++) {
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.H264ProfilesSupported[k] =
                    p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->H264ProfilesSupported[k];
        }
    }


}


if ( p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG ) {

    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasJPEG = 1;

    sizeResolutionsAvailable = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->__sizeResolutionsAvailable;

    if ( sizeResolutionsAvailable > 0) {

        sizeResolutionsAvailable = sizeResolutionsAvailable > MAX_RESOLUTIONS_AVAILABLE - 1 ?
                    MAX_RESOLUTIONS_AVAILABLE - 1 : sizeResolutionsAvailable;

        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.__sizeResolutionsAvailable =
                sizeResolutionsAvailable;

        for (k = 0; k < sizeResolutionsAvailable; k++)
        {
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.ResolutionsAvailable[k].Width
                    = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[k].Width;
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.ResolutionsAvailable[k].Height
                    = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[k].Height;
        }

    }

    if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange ) {
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.FrameRateRange.Max =
                p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange->Max;
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.FrameRateRange.Min =
                p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange->Min;

    }

    if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange ) {
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.EncodingIntervalRange.Max =
                p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange->Max;
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.EncodingIntervalRange.Min =
                p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange->Min;

    }

}


if ( p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4 )
{
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasMpeg4 = 1;
}
sizeResolutionsAvailable = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->__sizeResolutionsAvailable;

if ( sizeResolutionsAvailable > 0  ) {

    sizeResolutionsAvailable = sizeResolutionsAvailable > MAX_RESOLUTIONS_AVAILABLE - 1 ?
                MAX_RESOLUTIONS_AVAILABLE - 1 : sizeResolutionsAvailable;

    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.__sizeResolutionsAvailable =
            sizeResolutionsAvailable;

    for (k = 0; k < sizeResolutionsAvailable; k++)
    {
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.ResolutionsAvailable[k].Width
                = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->ResolutionsAvailable[k].Width;
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.ResolutionsAvailable[k].Height
                = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->ResolutionsAvailable[k].Height;
    }
}


int sizeMp4Profiles = p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->__sizeMpeg4ProfilesSupported;

if ( sizeMp4Profiles > 0  ) {
    sizeMp4Profiles = sizeMp4Profiles > MAX_H264_PROFILES ? MAX_H264_PROFILES - 1 : sizeMp4Profiles;
    for ( k = 0; k < sizeMp4Profiles; k++) {
        g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.Mpeg4ProfilesSupported[k] =
                p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->Mpeg4ProfilesSupported[k];

    }
}


if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->GovLengthRange ) {
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.GovLengthRange.Max =
            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->GovLengthRange->Max;
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.GovLengthRange.Min =
            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->GovLengthRange->Min;
}

if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->FrameRateRange ) {
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.FrameRateRange.Max =
            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->FrameRateRange->Max;
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.FrameRateRange.Min =
            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->FrameRateRange->Min;
}

if (p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->EncodingIntervalRange ) {
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.EncodingIntervalRange.Max =
            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->EncodingIntervalRange->Max;
    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.EncodingIntervalRange.Min =
            p_trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4->EncodingIntervalRange->Min;
}



}
#endif





















//获取视频配置信息（内部接口）
int GetVideoEncoderConfiguration( Remote_Device_Info *pDeviceInfo,  const char* ConfigurationToken )
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo )
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] )
    {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&媒体服务地址为空 \n");
        return -1;
    }
    int sizeResolutionsAvailable = 0;
    int k = 0;

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;

#endif
    soap_set_namespaces(soap, namespaces);
    soap_header(soap);


    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    struct _trt__GetVideoEncoderConfiguration *p_trt__GetVideoEncoderConfiguration = (struct _trt__GetVideoEncoderConfiguration *)soap_malloc(soap, sizeof( struct _trt__GetVideoEncoderConfiguration ));


    p_trt__GetVideoEncoderConfiguration->ConfigurationToken = (char*)soap_malloc(soap, 128);
    memset(p_trt__GetVideoEncoderConfiguration->ConfigurationToken, 0, 128);


    if ( ConfigurationToken ) {
        strncpy(p_trt__GetVideoEncoderConfiguration->ConfigurationToken, ConfigurationToken, MAX_PROF_TOKEN - 1 );
    }

    struct _trt__GetVideoEncoderConfigurationResponse *p_trt__GetVideoEncoderConfigurationResponse =
            soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationResponse));
    memset(p_trt__GetVideoEncoderConfigurationResponse, 0, sizeof( struct _trt__GetVideoEncoderConfigurationResponse ));

    soap_call___trt__GetVideoEncoderConfiguration(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL,p_trt__GetVideoEncoderConfiguration, p_trt__GetVideoEncoderConfigurationResponse );
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if (!soap->error)
    {

        if ( (-1 != index) && index < MAX_CAMERA )
        {
            memset(&g_onvifCameras.onvif_info[index].videoEncoderConfiguration, 0, sizeof(VideoEncoderConfiguration));
            if ( p_trt__GetVideoEncoderConfigurationResponse->Configuration )
            {
                g_onvifCameras.onvif_info[index].videoEncoderConfiguration.Quality =
                        p_trt__GetVideoEncoderConfigurationResponse->Configuration->Quality;

                if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->EncodingInterval )
                {
                    g_onvifCameras.onvif_info[index].videoEncoderConfiguration.EncodingInterval=
                            p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->EncodingInterval;
                }
                ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->FrameRateLimit )
                {
                    g_onvifCameras.onvif_info[index].videoEncoderConfiguration.FrameRateLimit =
                            p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->FrameRateLimit;
                }

                if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->BitrateLimit )
                {
                    g_onvifCameras.onvif_info[index].videoEncoderConfiguration.BitrateLimit =
                            p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->BitrateLimit;

                }
                if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution )
                {

                    g_onvifCameras.onvif_info[index].videoEncoderConfiguration.VideoResolution.Width
                            = p_trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution->Width;
                    g_onvifCameras.onvif_info[index].videoEncoderConfiguration.VideoResolution.Height
                            = p_trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution->Height;

                }
            }


            if ( p_trt__GetVideoEncoderConfigurationResponse->Configuration )
            {

                if ( p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264)
                {
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasH264 = 1;

                    if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264->GovLength )
                    {
                        g_onvifCameras.onvif_info[index].videoEncoderConfiguration.h264.GovLength=
                                p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264->GovLength;
                    }
                    if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264 )
                    {
                        g_onvifCameras.onvif_info[index].videoEncoderConfiguration.h264.H264Profile=
                                p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264->H264Profile;
                    }
                }

                if ( p_trt__GetVideoEncoderConfigurationResponse->Configuration )
                {
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasMpeg4 = 1;

                    if (p_trt__GetVideoEncoderConfigurationResponse->Configuration->MPEG4 )
                    {
                        g_onvifCameras.onvif_info[index].videoEncoderConfiguration.mpeg4.GovLength=
                                p_trt__GetVideoEncoderConfigurationResponse->Configuration->MPEG4->GovLength;
                        g_onvifCameras.onvif_info[index].videoEncoderConfiguration.mpeg4.Mpeg4Profile=
                                p_trt__GetVideoEncoderConfigurationResponse->Configuration->MPEG4->Mpeg4Profile;
                    }

                }
            }
        }
    }


    if (soap->error)
    {
        fprintf(stderr,"soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);

    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;

}



//获取视频配置信息（对外接口）
int ONVIF_GetVideoEncoderConfiguration(Remote_Device_Info *pDeviceInfo,  const char* ProfileToekn,const char * videoEncodertoken,
                                       Onvif_Video_Config *pGetVideoEncoderConfigurationResponse,Onvif_VideoEncoderConfigurationOptions * pGetVideoEncoderConfigurationOptionsResponse)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !videoEncodertoken || !pGetVideoEncoderConfigurationResponse )
    {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = 0;
    int ret = 0;
    int sizeOfCodecProfile  = 0;
    int k= 0;
    int sizeOfResolution = 0;


    index = ONVIF_GetCameraIndex(pDeviceInfo);
    if ( index < 0 )
    {
        return -1;
    }



    int result =  GetVideoEncoderConfigurationOptions(pDeviceInfo,ProfileToekn,videoEncodertoken);
    if(1!=result)
    {
        return -2;
    }

#if 0
    pGetVideoEncoderConfigurationOptionsResponse->H264Options.BitrateRange.Max =
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.BitrateRange.Max;
    pGetVideoEncoderConfigurationOptionsResponse->H264Options.BitrateRange.Min =
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.BitrateRange.Min;
#endif

    pGetVideoEncoderConfigurationOptionsResponse->H264Options.EncodingIntervalRange.Max =
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.EncodingIntervalRange.Max;
    pGetVideoEncoderConfigurationOptionsResponse->H264Options.EncodingIntervalRange.Min =
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.EncodingIntervalRange.Min;

    pGetVideoEncoderConfigurationOptionsResponse->H264Options.GovLengthRange.Max =
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.GovLengthRange.Max;
    pGetVideoEncoderConfigurationOptionsResponse->H264Options.GovLengthRange.Min =
            g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.GovLengthRange.Min;

     sizeOfCodecProfile = g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.__sizeH264ProfilesSupported;
    sizeOfCodecProfile = sizeOfCodecProfile > MAX_H264_PROFILES -1 ? MAX_H264_PROFILES -1 : sizeOfCodecProfile;

    for ( k = 0; k < sizeOfCodecProfile; k++ )
    {
        pGetVideoEncoderConfigurationOptionsResponse->H264Options.H264ProfilesSupported[k] =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.H264ProfilesSupported[k];
    }

    sizeOfResolution = g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.__sizeResolutionsAvailable;
    sizeOfResolution = sizeOfResolution > MAX_RESOLUTIONS_ITEMS - 1 ? MAX_RESOLUTIONS_ITEMS - 1 : sizeOfResolution;

    pGetVideoEncoderConfigurationOptionsResponse->H264Options.__sizeResolutionsAvailable = sizeOfResolution;

    for ( k = 0; k < sizeOfResolution; k++ )
    {
        pGetVideoEncoderConfigurationOptionsResponse->H264Options.ResolutionsAvailable[k].Width =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Width;
        pGetVideoEncoderConfigurationOptionsResponse->H264Options.ResolutionsAvailable[k].Height =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Height;

        ONVIF_DBP("*****************************%ld,%ld",g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Width,
                  g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.H264Options.ResolutionsAvailable[k].Height);

    }


#if 0
    if ( g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasJPEG )
    {
        pGetVideoEncoderConfigurationOptionsResponse->hasJPEG = 1;

        pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.FrameRateRange.Max =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.FrameRateRange.Max;
        pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.FrameRateRange.Min =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.FrameRateRange.Min;

        pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.EncodingIntervalRange.Max =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.EncodingIntervalRange.Max;
        pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.EncodingIntervalRange.Min =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.EncodingIntervalRange.Min;

        sizeOfResolution = g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.__sizeResolutionsAvailable;

        sizeOfResolution = sizeOfResolution > MAX_RESOLUTIONS_ITEMS - 1 ? MAX_RESOLUTIONS_ITEMS - 1 : sizeOfResolution;

        pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.__sizeResolutionsAvailable = sizeOfResolution;


        for ( k = 0; k < sizeOfResolution; k++ ) {
            pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.ResolutionsAvailable[k].Width =
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.ResolutionsAvailable[k].Width;
            pGetVideoEncoderConfigurationOptionsResponse->JpegOptions.ResolutionsAvailable[k].Height =
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.JpegOptions.ResolutionsAvailable[k].Height;

        }
    }

    if ( g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasMpeg4 )
    {
        pGetVideoEncoderConfigurationOptionsResponse->hasMpeg4 = 1;


        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.FrameRateRange.Max =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.FrameRateRange.Max;
        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.FrameRateRange.Min =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.FrameRateRange.Min;

        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.EncodingIntervalRange.Max =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.EncodingIntervalRange.Max;
        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.EncodingIntervalRange.Min =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.EncodingIntervalRange.Min;

        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.GovLengthRange.Max =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.GovLengthRange.Max;
        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.GovLengthRange.Min =
                g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.GovLengthRange.Min;

        sizeOfCodecProfile = g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.__sizeMpeg4ProfilesSupported;

        sizeOfCodecProfile = sizeOfCodecProfile > MAX_H264_PROFILES -1 ? MAX_H264_PROFILES -1 : sizeOfCodecProfile;

        for ( k = 0; k < sizeOfCodecProfile; k++ ) {
            pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.Mpeg4ProfilesSupported[k] =
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.Mpeg4ProfilesSupported[k];
        }

        sizeOfResolution = g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.__sizeResolutionsAvailable;
        sizeOfResolution = sizeOfResolution > MAX_RESOLUTIONS_ITEMS - 1 ? MAX_RESOLUTIONS_ITEMS - 1 : sizeOfResolution;

        pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.__sizeResolutionsAvailable = sizeOfResolution;

        for ( k = 0; k < sizeOfResolution; k++ ) {
            pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.ResolutionsAvailable[k].Width =
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.ResolutionsAvailable[k].Width;
            pGetVideoEncoderConfigurationOptionsResponse->Mpeg4Options.ResolutionsAvailable[k].Height =
                    g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.Mpeg4Options.ResolutionsAvailable[k].Height;
        }


    }


#endif




     result = GetVideoEncoderConfiguration(pDeviceInfo, videoEncodertoken);
    if ( 1 != result )
    {
        return -3;
    }
    memset(pGetVideoEncoderConfigurationResponse, 0, sizeof(Onvif_Video_Config));

    pGetVideoEncoderConfigurationResponse->Quality =
            g_onvifCameras.onvif_info[index].videoEncoderConfiguration.Quality;
    pGetVideoEncoderConfigurationResponse->FrameRateLimit =
            g_onvifCameras.onvif_info[index].videoEncoderConfiguration.FrameRateLimit;
    pGetVideoEncoderConfigurationResponse->BitrateLimit =
            g_onvifCameras.onvif_info[index].videoEncoderConfiguration.BitrateLimit;
    pGetVideoEncoderConfigurationResponse->EncodingInterval =
            g_onvifCameras.onvif_info[index].videoEncoderConfiguration.EncodingInterval;
    pGetVideoEncoderConfigurationResponse->height =
            g_onvifCameras.onvif_info[index].videoEncoderConfiguration.VideoResolution.Height;
    pGetVideoEncoderConfigurationResponse->width =
            g_onvifCameras.onvif_info[index].videoEncoderConfiguration.VideoResolution.Width;


    if (1 == g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasH264 )
    {
        pGetVideoEncoderConfigurationResponse->videoEncoding = 2;
        pGetVideoEncoderConfigurationResponse->h264.GovLength =
                g_onvifCameras.onvif_info[index].videoEncoderConfiguration.h264.GovLength;
        pGetVideoEncoderConfigurationResponse->h264.H264Profile =
                g_onvifCameras.onvif_info[index].videoEncoderConfiguration.h264.H264Profile;

    }
    if (1== g_onvifCameras.onvif_info[index].videoEncoderConfigurationOptions.hasMpeg4  )
    {
        pGetVideoEncoderConfigurationResponse->videoEncoding = 1;

        pGetVideoEncoderConfigurationResponse->mpeg4.GovLength =
                g_onvifCameras.onvif_info[index].videoEncoderConfiguration.mpeg4.GovLength;
        pGetVideoEncoderConfigurationResponse->mpeg4.Mpeg4Profile =
                g_onvifCameras.onvif_info[index].videoEncoderConfiguration.mpeg4.Mpeg4Profile;

    }

    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return result;

}

int ONVIF_SetVideoEncoderConfiguration(Remote_Device_Info *pDeviceInfo, Onvif_Video_Config *pSetVideoEncoderConfig)
{

    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&Media服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);



    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _trt__GetVideoEncoderConfiguration *p_trt__GetVideoEncoderConfiguration = (struct _trt__GetVideoEncoderConfiguration *)soap_malloc(soap, sizeof( struct _trt__GetVideoEncoderConfiguration ));

    p_trt__GetVideoEncoderConfiguration->ConfigurationToken = (char*)soap_malloc(soap, 128);
    memset(p_trt__GetVideoEncoderConfiguration->ConfigurationToken, 0, 128);


    if ( pSetVideoEncoderConfig->token )
    {
        strncpy(p_trt__GetVideoEncoderConfiguration->ConfigurationToken, pSetVideoEncoderConfig->token, MAX_PROF_TOKEN - 1 );
    }

    struct _trt__GetVideoEncoderConfigurationResponse *p_trt__GetVideoEncoderConfigurationResponse =
            soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationResponse));
    memset(p_trt__GetVideoEncoderConfigurationResponse, 0, sizeof( struct _trt__GetVideoEncoderConfigurationResponse ));

    soap_call___trt__GetVideoEncoderConfiguration(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL,p_trt__GetVideoEncoderConfiguration, p_trt__GetVideoEncoderConfigurationResponse );

    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }
    struct _trt__SetVideoEncoderConfiguration *p_trt__SetVideoEncoderConfiguration =(struct _trt__SetVideoEncoderConfiguration *)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfiguration));
    //memset(p_trt__SetVideoEncoderConfiguration, 0, sizeof(struct _trt__SetVideoEncoderConfiguration));
    struct _trt__SetVideoEncoderConfigurationResponse * p_trt__SetVideoEncoderConfigurationResponse =(struct _trt__SetVideoEncoderConfigurationResponse *)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfigurationResponse));
    //memset(p_trt__SetVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__SetVideoEncoderConfigurationResponse));


    p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->BitrateLimit =  pSetVideoEncoderConfig->BitrateLimit;
    p_trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->FrameRateLimit = pSetVideoEncoderConfig->FrameRateLimit;

    p_trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution->Width = pSetVideoEncoderConfig->width;
    p_trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution->Height = pSetVideoEncoderConfig->height;
#if 0
    p_trt__GetVideoEncoderConfigurationResponse->Configuration->Quality = pSetVideoEncoderConfig->Quality;

    if ( tt__VideoEncoding__H264 == pSetVideoEncoderConfig->videoEncoding )
    {
        p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264->GovLength = pSetVideoEncoderConfig->h264.GovLength;
        p_trt__GetVideoEncoderConfigurationResponse->Configuration->H264->H264Profile = pSetVideoEncoderConfig->h264.H264Profile;
    }

#endif
    p_trt__SetVideoEncoderConfiguration->ForcePersistence = xsd__boolean__true_;
    p_trt__SetVideoEncoderConfiguration->Configuration = p_trt__GetVideoEncoderConfigurationResponse->Configuration;

    soap_call___trt__SetVideoEncoderConfiguration(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL, p_trt__SetVideoEncoderConfiguration, p_trt__SetVideoEncoderConfigurationResponse);
    if (soap->error)
    {
        fprintf(stderr,"soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;



#if 0
    p_trt__SetVideoEncoderConfiguration->Configuration =
            (struct tt__VideoEncoderConfiguration *)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfiguration));
    memset(p_trt__SetVideoEncoderConfiguration->Configuration, 0, sizeof(struct tt__VideoEncoderConfiguration));

    p_trt__SetVideoEncoderConfiguration->Configuration->Encoding = pSetVideoEncoderConfig->videoEncoding;

    if ( pSetVideoEncoderConfig->Name )
    {
        if ( pSetVideoEncoderConfig->Name[0] ) {
            p_trt__SetVideoEncoderConfiguration->Configuration->Name = (char*)soap_malloc(soap, 128);
            strncpy(p_trt__SetVideoEncoderConfiguration->Configuration->Name, pSetVideoEncoderConfig->Name, 127);
            p_trt__SetVideoEncoderConfiguration->Configuration->Name[127] = '\0';
        }
    }

    if ( pSetVideoEncoderConfig->token )
    {
        if ( pSetVideoEncoderConfig->token[0] )
        {
            p_trt__SetVideoEncoderConfiguration->Configuration->token = (char*)soap_malloc(soap, 128);
            strncpy(p_trt__SetVideoEncoderConfiguration->Configuration->token, pSetVideoEncoderConfig->token, 127);
            p_trt__SetVideoEncoderConfiguration->Configuration->token[127]= '\0';
        }

    }
    p_trt__SetVideoEncoderConfiguration->ForcePersistence = xsd__boolean__true_;
    p_trt__SetVideoEncoderConfiguration->Configuration->Resolution =
            (struct tt__VideoResolution *)soap_malloc(soap, sizeof(struct tt__VideoResolution ));
    memset( p_trt__SetVideoEncoderConfiguration->Configuration->Resolution, 0, sizeof(struct tt__VideoResolution));


#if 1
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast =
            (struct tt__MulticastConfiguration *)soap_malloc(soap, sizeof(struct tt__MulticastConfiguration ));

    // p_trt__SetVideoEncoderConfiguration->Configuration->Multicast= p_trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast;

#endif
#if 1
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address =
            (struct tt__IPAddress *)soap_malloc(soap, sizeof(struct tt__IPAddress ));
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->Type= tt__IPType__IPv4;
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv4Address = (char*)soap_malloc(soap, 64);
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv4Address = "0.0.0.0";
    // p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv4Address = p_trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Address->IPv4Address;
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->TTL =1;
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->Port = 8600;
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->AutoStart =xsd__boolean__false_;
    p_trt__SetVideoEncoderConfiguration->Configuration->Multicast->__size=0;

#endif
    // p_trt__SetVideoEncoderConfiguration->Configuration->UseCount =  p_trt__GetVideoEncoderConfigurationResponse->Configuration->UseCount;

    p_trt__SetVideoEncoderConfiguration->Configuration->UseCount = 1;
    p_trt__SetVideoEncoderConfiguration->Configuration->SessionTimeout=  5;
    p_trt__SetVideoEncoderConfiguration->Configuration->Resolution->Width =  pSetVideoEncoderConfig->width;
    p_trt__SetVideoEncoderConfiguration->Configuration->Resolution->Height =  pSetVideoEncoderConfig->height;


    fprintf(stderr,"width =%d,height =%d \n",p_trt__SetVideoEncoderConfiguration->Configuration->Resolution->Width ,p_trt__SetVideoEncoderConfiguration->Configuration->Resolution->Height);

    p_trt__SetVideoEncoderConfiguration->Configuration->RateControl =
            (struct tt__VideoRateControl *)soap_malloc(soap, sizeof(struct tt__VideoRateControl));
    memset( p_trt__SetVideoEncoderConfiguration->Configuration->RateControl, 0, sizeof(struct tt__VideoRateControl));


    p_trt__SetVideoEncoderConfiguration->Configuration->RateControl->FrameRateLimit = pSetVideoEncoderConfig->FrameRateLimit;
    p_trt__SetVideoEncoderConfiguration->Configuration->RateControl->BitrateLimit = pSetVideoEncoderConfig->BitrateLimit;
    p_trt__SetVideoEncoderConfiguration->Configuration->RateControl->EncodingInterval = pSetVideoEncoderConfig->EncodingInterval;

    p_trt__SetVideoEncoderConfiguration->Configuration->Quality = pSetVideoEncoderConfig->Quality;

    if ( tt__VideoEncoding__H264 == pSetVideoEncoderConfig->videoEncoding )
    {
        p_trt__SetVideoEncoderConfiguration->Configuration->H264 =
                (struct tt__H264Configuration *)soap_malloc(soap, sizeof(struct tt__H264Configuration));

        memset(p_trt__SetVideoEncoderConfiguration->Configuration->H264, 0, sizeof(struct tt__H264Configuration));
        p_trt__SetVideoEncoderConfiguration->Configuration->H264->GovLength = pSetVideoEncoderConfig->h264.GovLength;
        p_trt__SetVideoEncoderConfiguration->Configuration->H264->H264Profile = pSetVideoEncoderConfig->h264.H264Profile;


    } else if ( tt__VideoEncoding__JPEG == pSetVideoEncoderConfig->videoEncoding )
    {

    } else if ( tt__VideoEncoding__MPEG4 == pSetVideoEncoderConfig->videoEncoding )
    {
        p_trt__SetVideoEncoderConfiguration->Configuration->MPEG4 =
                (struct tt__Mpeg4Configuration *)soap_malloc(soap, sizeof(struct tt__Mpeg4Configuration));

        p_trt__SetVideoEncoderConfiguration->Configuration->MPEG4->GovLength = pSetVideoEncoderConfig->mpeg4.GovLength;
        p_trt__SetVideoEncoderConfiguration->Configuration->MPEG4->Mpeg4Profile = pSetVideoEncoderConfig->mpeg4.Mpeg4Profile;

    }


    struct _trt__SetVideoEncoderConfigurationResponse *p_trt__SetVideoEncoderConfigurationResponse =
            (struct _trt__SetVideoEncoderConfigurationResponse *)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfigurationResponse));
            memset(p_trt__SetVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__SetVideoEncoderConfigurationResponse));




            soap_call___trt__SetVideoEncoderConfiguration(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr, NULL, p_trt__SetVideoEncoderConfiguration, p_trt__SetVideoEncoderConfigurationResponse);


            if (soap->error)
            {
                fprintf(stderr,"soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
            }
            soap_destroy(soap);
            soap_end(soap);
            soap_done(soap);
            soap->error = (soap->error == 0 ? 1 : -1);
            ONVIF_DBP("################%s\n",pDeviceInfo->ip);
            return soap->error;

#endif

}



//***************************PTZ模块***********************


#define YEAR_IN_SEC (31556926)
#define MONTH_IN_SEC (2629744)
#define DAY_IN_SEC (86400)
#define HOURS_IN_SEC (3600)
#define MIN_IN_SEC (60)

long epoch_convert_switch(int value, char convert, int time)
{
    long seconds = 0;
    switch(convert)
    {
    case 'Y': seconds = value * YEAR_IN_SEC ;
        break;
    case 'M':
        if(time == 1)
        {
            seconds = value * MIN_IN_SEC;
        }
        else
        {
            seconds = value * MONTH_IN_SEC;
        }
        break;
    case 'D': seconds = value * DAY_IN_SEC;
        break;
    case 'H': seconds = value * HOURS_IN_SEC;
        break;
    case 'S': seconds = value;
        break;
    }
    return seconds;
}



long periodtol(char *ptr)
{
    char buff[10] = "0";
    char convert;
    int i = 0;
    int value = 0;
    int time = 0;
    int minus = 0;
    long cumulative = 0;
    if(*ptr == '-')
    {
        ptr++;
        minus = 1;
    }
    while(*ptr != '\0')
    {

        if(*ptr == 'P' || *ptr == 'T')
        {
            ptr++;
            if(*ptr == 'T')
            {
                time = 1;
                ptr++;
            }
        }
        else
        {
            if(*ptr >= '0' && *ptr <= '9')
            {
                buff[i] = *ptr;
                i++;
                ptr++;
            }
            else
            {
                buff[i] = 0;
                value = atoi(buff);
                memset(buff, 0, sizeof(buff));
                i = 0;
                convert = *ptr;
                ptr++;
                cumulative = cumulative + epoch_convert_switch(value, convert, time);
            }
        }
    }
    if(minus == 1)
    {
        return -cumulative;
    }
    else
    {
        return cumulative;
    }
}



int ONVIF_PtzGetConfigurationOptions(Remote_Device_Info *pDeviceInfo, const char *ConfigurationToken, Onvif_Ptz_ConfigOtions *pGetPtzConfigOtionsReponse)
{

    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !pGetPtzConfigOtionsReponse ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {

        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;

#endif
    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tptz__GetConfigurationOptions *p_tptz__GetConfigurationOptions =
            (struct _tptz__GetConfigurationOptions *)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationOptions ));
            p_tptz__GetConfigurationOptions->ConfigurationToken = (char*)soap_malloc(soap, 64);
            memset(p_tptz__GetConfigurationOptions->ConfigurationToken, 0, 64);

            if ( ConfigurationToken ) {
                strncpy(p_tptz__GetConfigurationOptions->ConfigurationToken, ConfigurationToken, 63);
                p_tptz__GetConfigurationOptions->ConfigurationToken[63] = '\0';
            }

            struct _tptz__GetConfigurationOptionsResponse *p_tptz__GetConfigurationOptionsResponse =
                    (struct _tptz__GetConfigurationOptionsResponse *)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationOptionsResponse));
                    memset(p_tptz__GetConfigurationOptionsResponse, 0, sizeof( p_tptz__GetConfigurationOptionsResponse ));

                    soap_call___tptz__GetConfigurationOptions(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p_tptz__GetConfigurationOptions, p_tptz__GetConfigurationOptionsResponse);

                    if ( !soap->error) {

                        if ( p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions) {

                            if ( p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->PTZTimeout ) {
                                pGetPtzConfigOtionsReponse->TimeOutRange.Max = p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->PTZTimeout->Max;
                                pGetPtzConfigOtionsReponse->TimeOutRange.Min = p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->PTZTimeout->Min;

                            }
                            if ( p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces) {

                                if ( p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->__sizeContinuousPanTiltVelocitySpace ) {
                                    pGetPtzConfigOtionsReponse->PanTiltVelocityRangeX.Min =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->ContinuousPanTiltVelocitySpace[0].XRange->Min;
                                    pGetPtzConfigOtionsReponse->PanTiltVelocityRangeX.Max =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->ContinuousPanTiltVelocitySpace[0].XRange->Max;

                                    pGetPtzConfigOtionsReponse->PanTiltVelocityRangeY.Min =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->ContinuousPanTiltVelocitySpace[0].YRange->Min;
                                    pGetPtzConfigOtionsReponse->PanTiltVelocityRangeY.Max =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->ContinuousPanTiltVelocitySpace[0].YRange->Max;


                                    pGetPtzConfigOtionsReponse->ZoomVelocityRangeX.Min =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->ContinuousZoomVelocitySpace[0].XRange->Min;
                                    pGetPtzConfigOtionsReponse->ZoomVelocityRangeX.Max =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->ContinuousZoomVelocitySpace[0].XRange->Max;
                                }
                                if ( p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->__sizePanTiltSpeedSpace ) {
                                    pGetPtzConfigOtionsReponse->PanTiltSpeedRangeX.Min =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->PanTiltSpeedSpace[0].XRange->Min;
                                    pGetPtzConfigOtionsReponse->PanTiltSpeedRangeX.Max =
                                            p_tptz__GetConfigurationOptionsResponse->PTZConfigurationOptions->Spaces->PanTiltSpeedSpace[0].XRange->Max;
                                }
                            }
                        }
                    }

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);
                    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                    return soap->error;
}


int ONVIF_PtzGetConfiguration(Remote_Device_Info *pDeviceInfo, Onvif_Ptz_Config *pGetPtzConfig)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !pGetPtzConfig ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }

    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif
    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _tptz__GetConfiguration *p_tptz__GetConfiguration =
            (struct _tptz__GetConfiguration *)soap_malloc(soap, sizeof( struct _tptz__GetConfiguration ));
            memset(p_tptz__GetConfiguration, 0, sizeof(struct _tptz__GetConfiguration ));
            p_tptz__GetConfiguration->PTZConfigurationToken =
                    (struct tt__ReferenceToken *)soap_malloc(soap, sizeof(tt__ReferenceToken )*64);


            strncpy(p_tptz__GetConfiguration->PTZConfigurationToken,pGetPtzConfig->token,MAX_LEN -1);
            struct _tptz__GetConfigurationResponse *p_tptz__GetConfigurationResponse =
                    (struct _tptz__GetConfigurationResponse *)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationResponse));
                    soap_call___tptz__GetConfiguration(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p_tptz__GetConfiguration, p_tptz__GetConfigurationResponse);
                    if ( !soap->error ) {
                        if ( p_tptz__GetConfigurationResponse->PTZConfiguration->token ) {
                            strncpy(pGetPtzConfig->token,
                                    p_tptz__GetConfigurationResponse->PTZConfiguration->token, MAX_LEN -1 );
                        }

                        if ( p_tptz__GetConfigurationResponse->PTZConfiguration->Name) {
                            strncpy(pGetPtzConfig->name,
                                    p_tptz__GetConfigurationResponse->PTZConfiguration->Name, MAX_LEN -1 );
                        }

                        if ( p_tptz__GetConfigurationResponse->PTZConfiguration->NodeToken) {
                            strncpy(pGetPtzConfig->NodeToken,
                                    p_tptz__GetConfigurationResponse->PTZConfiguration->NodeToken, MAX_LEN -1 );
                        }

                        if ( p_tptz__GetConfigurationResponse->PTZConfiguration->DefaultPTZSpeed ) {
                            if ( p_tptz__GetConfigurationResponse->PTZConfiguration->DefaultPTZSpeed->PanTilt ) {
                                pGetPtzConfig->DefaultPanTiltSpeedX =
                                        p_tptz__GetConfigurationResponse->PTZConfiguration->DefaultPTZSpeed->PanTilt->x;
                                pGetPtzConfig->DefaultPanTiltSpeedY =
                                        p_tptz__GetConfigurationResponse->PTZConfiguration->DefaultPTZSpeed->PanTilt->y;
                            }
                        }

                        ONVIF_DBP(" &&&&&&&&&&&&&timeout=%ld \n",*p_tptz__GetConfigurationResponse->PTZConfiguration->DefaultPTZTimeout);
                    }

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);
                    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                    return soap->error;

}


int ONVIF_PtzGotoPreset(Remote_Device_Info *pDeviceInfo, const char *profileToken, const char *presetToken)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !presetToken) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif
    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _tptz__GotoPreset *p_tptz__GotoPreset = ( struct _tptz__GotoPreset *)soap_malloc(soap, sizeof(struct _tptz__GotoPreset));
    memset(p_tptz__GotoPreset, 0, sizeof(struct _tptz__GotoPreset));

    p_tptz__GotoPreset->ProfileToken = (char*)soap_malloc(soap, 64);
    memset(p_tptz__GotoPreset->ProfileToken, 0, 64);
    p_tptz__GotoPreset->PresetToken = (char*)soap_malloc(soap, 64);
    memset(p_tptz__GotoPreset->PresetToken, 0, 64);

    if ( profileToken ) {
        strncpy(p_tptz__GotoPreset->ProfileToken, profileToken, 63);
    }

    strncpy(p_tptz__GotoPreset->PresetToken, presetToken, 63);

    soap_call___tptz__GotoPreset(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p_tptz__GotoPreset, NULL);
    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;

}

int ONVIF_PtzSetPreset(Remote_Device_Info *pDeviceInfo, const char * profileToken ,const char *presetName, const char *presetToken )
{

    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !presetToken) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {

        return -1;
    }

    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif
    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tptz__SetPreset p_tptz__SetPreset ;
    struct _tptz__SetPresetResponse p_tptz__SetPresetResponse =  {0};
    p_tptz__SetPreset.ProfileToken = (char*)soap_malloc(soap, 64);
    memset(p_tptz__SetPreset.ProfileToken, 0,  64 );

    p_tptz__SetPreset.PresetName = (char*)soap_malloc(soap, 64);
    memset(p_tptz__SetPreset.PresetName, 0,  64 );

    p_tptz__SetPreset.PresetToken = (char*)soap_malloc(soap, 64);
    memset(p_tptz__SetPreset.PresetToken, 0,  64 );

    if (presetName)
    {
        strncpy(p_tptz__SetPreset.PresetName, presetName, 63);
    }

    strncpy(p_tptz__SetPreset.ProfileToken, profileToken, 63);
    strncpy(p_tptz__SetPreset.PresetToken, presetToken, 63);


    soap_call___tptz__SetPreset(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL,&p_tptz__SetPreset, &p_tptz__SetPresetResponse);
    if ( p_tptz__SetPresetResponse.PresetToken )
    {
        printf("	presetToken %s \n", p_tptz__SetPresetResponse.PresetToken);
    }
    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;

}


int ONVIF_PtzRemovePreset( Remote_Device_Info *pDeviceInfo, const char *profileToken, const char *presetToken )
{
    ONVIF_DBP("=============%s: %s: %d  \n",pDeviceInfo->ip ,__func__,__LINE__ );
    if ( !pDeviceInfo || !presetToken) {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;

#endif
    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tptz__RemovePreset p_tptz__RemovePreset ;
    struct _tptz__RemovePresetResponse  p_tptz__RemovePresetResponse ;

    p_tptz__RemovePreset.ProfileToken = (char*)soap_malloc(soap, 64);
    memset(p_tptz__RemovePreset.ProfileToken, 0, 64);
    p_tptz__RemovePreset.PresetToken = (char*)soap_malloc(soap, 64);
    memset(p_tptz__RemovePreset.PresetToken, 0, 64);

    if ( profileToken ) {
        strncpy(p_tptz__RemovePreset.ProfileToken, profileToken, 63);
    }

    strncpy(p_tptz__RemovePreset.PresetToken, presetToken, 63);
    soap_call___tptz__RemovePreset(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, &p_tptz__RemovePreset, &p_tptz__RemovePresetResponse);

    if (soap->error)
    {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("=============%s: %s: %d  \n",pDeviceInfo->ip ,__func__,__LINE__ );
    return soap->error;


}

//#define  MIN_SPEED  0.125

#define  MIN_SPEED  0.05
int ONVIF_PtzContinueMove(Remote_Device_Info *pDeviceInfo, ONVIF_PTZ__ContinuousMove *pPtzContinuousMove )
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    struct timeval v1;
    gettimeofday(&v1, NULL);
    //fprintf(stderr, "\n##############################Enter ONVIF_PtzContinueMove time %d", v1.tv_sec * 1000 + v1.tv_usec / 1000);
    if ( !pDeviceInfo || !pPtzContinuousMove ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] || !pPtzContinuousMove->ProfileToken[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tptz__ContinuousMove *p_tptz__ContinuousMove =
            (struct _tptz__ContinuousMove *)soap_malloc(soap, sizeof( struct _tptz__ContinuousMove ) );
            memset(p_tptz__ContinuousMove, 0, sizeof( struct _tptz__ContinuousMove ));
            struct _tptz__ContinuousMoveResponse *p_tptz__ContinuousMoveResponse =
                    (struct _tptz__ContinuousMoveResponse *)soap_malloc(soap, sizeof( struct _tptz__ContinuousMoveResponse) );
                    memset(p_tptz__ContinuousMoveResponse, 0, sizeof( struct _tptz__ContinuousMoveResponse ) );

                    p_tptz__ContinuousMove->ProfileToken= pPtzContinuousMove->ProfileToken;

                    //p_tptz__ContinuousMove->Timeout =   ( xsd__duration *)soap_malloc(soap, sizeof( xsd__duration) );

                    // *p_tptz__ContinuousMove->Timeout =pPtzContinuousMove->Timeout;
                    // fprintf(stderr,"%ld\n",*p_tptz__ContinuousMove->Timeout);

                    p_tptz__ContinuousMove->Velocity =
                            (struct tt__PTZSpeed *)soap_malloc(soap, sizeof( struct tt__PTZSpeed ) );
                    memset(p_tptz__ContinuousMove->Velocity, 0, sizeof( struct tt__PTZSpeed ) );

                    // speed 0 - 7
                    int speed = pPtzContinuousMove->Speed % 8;

                    if ( pPtzContinuousMove->isPan )
                    {
                        p_tptz__ContinuousMove->Velocity->PanTilt =
                                (struct tt__Vector2D *)soap_malloc(soap, sizeof( struct tt__Vector2D ) );
                        memset(p_tptz__ContinuousMove->Velocity->PanTilt, 0, sizeof( struct tt__Vector2D ));


                        p_tptz__ContinuousMove->Velocity->PanTilt->space= "http://www.onvif.org/ver10/tptz/PanTiltSpaces/VelocityGenericSpace";


                        if ( PTZ_UP == pPtzContinuousMove->direction )
                        {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y = fabs((float)(speed * MIN_SPEED));
                            p_tptz__ContinuousMove->Velocity->PanTilt->x = 0.0;
                        }

                        if ( PTZ_DOWN == pPtzContinuousMove->direction ) {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y = - fabs((float)(speed * MIN_SPEED));
                            p_tptz__ContinuousMove->Velocity->PanTilt->x = 0.0;
                        }

                        if ( PTZ_LEFT == pPtzContinuousMove->direction ) {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y = 0.0;
                            p_tptz__ContinuousMove->Velocity->PanTilt->x = - fabs((float)(speed * MIN_SPEED));
                        }
                        if ( PTZ_RIGHT == pPtzContinuousMove->direction ) {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y = 0.0;
                            p_tptz__ContinuousMove->Velocity->PanTilt->x = fabs((float)(speed * MIN_SPEED));
                        }

                        if ( PTZ_LEFT_UP == pPtzContinuousMove->direction ) {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y = fabs((float)(speed * MIN_SPEED));
                            p_tptz__ContinuousMove->Velocity->PanTilt->x = - fabs((float)(speed * MIN_SPEED));


                        }

                        if ( PTZ_LEFT_DOWN == pPtzContinuousMove->direction ) {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y = - fabs((float)(speed * MIN_SPEED));
                            p_tptz__ContinuousMove->Velocity->PanTilt->x = - fabs((float)(speed * MIN_SPEED));
                        }

                        if ( PTZ_RIGHT_UP == pPtzContinuousMove->direction ) {
                            p_tptz__ContinuousMove->Velocity->PanTilt->y =  fabs((float)(speed * MIN_SPEED));
                            p_tptz__ContinuousMove->Velocity->PanTilt->x =  fabs((float)(speed * MIN_SPEED));
                        }

                        if ( PTZ_RIGHT_DOWN == pPtzContinuousMove->direction ) {

                            p_tptz__ContinuousMove->Velocity->PanTilt->y =  - fabs((float)(speed * MIN_SPEED));
                            p_tptz__ContinuousMove->Velocity->PanTilt->x =  fabs((float)(speed * MIN_SPEED));
                            //  ONVIF_DBP("%lf,%lf",p_tptz__ContinuousMove->Velocity->PanTilt->x,p_tptz__ContinuousMove->Velocity->PanTilt->y);
                        }
                    }

                    if ( pPtzContinuousMove->isZoom )
                    {
                        p_tptz__ContinuousMove->Velocity->Zoom =
                                (struct tt__Vector1D *)soap_malloc(soap, sizeof(struct tt__Vector1D));
                        memset(p_tptz__ContinuousMove->Velocity->Zoom, 0, sizeof(struct tt__Vector1D));
                        p_tptz__ContinuousMove->Velocity->Zoom->space = (char*)soap_malloc(soap, 128);
                        p_tptz__ContinuousMove->Velocity->Zoom->space = "http://www.onvif.org/ver10/tptz/ZoomSpaces/VelocityGenericSpace";
                        p_tptz__ContinuousMove->Velocity->Zoom->x = (float)(speed * 0.125);
                    }

                    soap_call___tptz__ContinuousMove(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p_tptz__ContinuousMove, p_tptz__ContinuousMoveResponse);
                    if (soap->error)
                    {
                        fprintf(stderr,"soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);
                    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                    return soap->error;
}



int ONVIF_PtzGetNodes(Remote_Device_Info *pDeviceInfo, ONVIF_GetNodesResponse *pGetNodesResponse)
{
    ONVIF_DBP("come here \n");
    if ( !pDeviceInfo || !pGetNodesResponse ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tptz__GetNodes *p_tptz__GetNodes  =
            (struct _tptz__GetNodes *)soap_malloc(soap, sizeof(struct _tptz__GetNodes));
            memset(p_tptz__GetNodes, 0, sizeof(struct _tptz__GetNodes));

            struct _tptz__GetNodesResponse *p_tptz__GetNodesResponse =
                    (struct _tptz__GetNodesResponse *)soap_malloc(soap, sizeof(struct _tptz__GetNodesResponse ));

                    soap_call___tptz__GetNodes(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p_tptz__GetNodes, p_tptz__GetNodesResponse);

                    if ( !soap->error )
                    {
                        int k = 0;
                        int sizeOfNodes = p_tptz__GetNodesResponse->__sizePTZNode;

                        sizeOfNodes = sizeOfNodes > MAX_PTZ_PRESETS - 1 ? MAX_PTZ_PRESETS - 1 : sizeOfNodes;
                        ONVIF_DBP(" &&&&&&&&&&&&&sizeOfNodes ==%d \n",sizeOfNodes);
                        memset(pGetNodesResponse, 0, sizeof( ONVIF_GetNodesResponse ) );
                        pGetNodesResponse->__sizePTZNode = sizeOfNodes;

                        for ( k = 0; k < sizeOfNodes; k++ )
                        {

                            strncpy(pGetNodesResponse->PTZNode[k].PTZNodetoken,p_tptz__GetNodesResponse->PTZNode[k].token,63);
                            ONVIF_DBP(" &&&&&&&&&&&&&PTZNodetoken ==%s \n",pGetNodesResponse->PTZNode[k].PTZNodetoken);
                            if(p_tptz__GetNodesResponse->PTZNode[k].Name)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].PTZNodeName,p_tptz__GetNodesResponse->PTZNode[k].Name,63);
                            }

                            //1
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeAbsolutePanTiltPositionSpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeAbsolutePanTiltPositionSpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsolutePanTiltPositionSpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsolutePanTiltPositionSpace->URI,MAX_URL_LEN);
                                ONVIF_DBP(" &&&&&&&&&&&&&AbsolutePanTiltPositionSpace ==%s \n",pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.URI);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.XRange.Max = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsolutePanTiltPositionSpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.XRange.Min = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsolutePanTiltPositionSpace->XRange->Min;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.YRange.Max = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsolutePanTiltPositionSpace->YRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.YRange.Min = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsolutePanTiltPositionSpace->YRange->Min;
                            ONVIF_DBP("xmax= %d ,%d, ymax =%d,%d \n",pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.XRange.Max,
                                      pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.XRange.Min,
                                      pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.YRange.Max,
                                      pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsolutePanTiltPositionSpace.YRange.Min);
                            //2
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeAbsoluteZoomPositionSpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeAbsoluteZoomPositionSpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsoluteZoomPositionSpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsoluteZoomPositionSpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsoluteZoomPositionSpace->URI,MAX_URL_LEN);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsoluteZoomPositionSpace.XRange.Max =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsoluteZoomPositionSpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsoluteZoomPositionSpace.XRange.Min =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsoluteZoomPositionSpace->XRange->Min;


                            //pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.AbsoluteZoomPositionSpace.YRange = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->AbsoluteZoomPositionSpace.YRange;

                            //3
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeRelativePanTiltTranslationSpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeRelativePanTiltTranslationSpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativePanTiltTranslationSpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativePanTiltTranslationSpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativePanTiltTranslationSpace->URI,MAX_URL_LEN);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativePanTiltTranslationSpace.XRange.Max = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativePanTiltTranslationSpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativePanTiltTranslationSpace.XRange.Min = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativePanTiltTranslationSpace->XRange->Min;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativePanTiltTranslationSpace.YRange.Max = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativePanTiltTranslationSpace->YRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativePanTiltTranslationSpace.YRange.Min = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativePanTiltTranslationSpace->YRange->Min;
                            //4
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeRelativeZoomTranslationSpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeRelativeZoomTranslationSpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativeZoomTranslationSpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativeZoomTranslationSpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativeZoomTranslationSpace->URI,MAX_URL_LEN);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativeZoomTranslationSpace.XRange.Max =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativeZoomTranslationSpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativeZoomTranslationSpace.XRange.Min =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativeZoomTranslationSpace->XRange->Min;
                            //pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.RelativeZoomTranslationSpace.YRange = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->RelativeZoomTranslationSpace.YRange;

                            //5
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeContinuousPanTiltVelocitySpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeContinuousPanTiltVelocitySpace;
                            // ONVIF_DBP(" &&&&&&&&&&&&&PTZNodetoken ==%d \n",p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeContinuousPanTiltVelocitySpace);
                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousPanTiltVelocitySpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->URI,MAX_URL_LEN);
                                //  ONVIF_DBP(" &&&&&&&&&&&&&PTZNodeturi ==%s \n",p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->URI);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousPanTiltVelocitySpace.XRange.Max = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousPanTiltVelocitySpace.XRange.Min = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->XRange->Min;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousPanTiltVelocitySpace.YRange.Max = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->YRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousPanTiltVelocitySpace.YRange.Min = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousPanTiltVelocitySpace->YRange->Min;
                            //6

                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeContinuousZoomVelocitySpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeContinuousZoomVelocitySpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousZoomVelocitySpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousZoomVelocitySpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousZoomVelocitySpace->URI,MAX_URL_LEN);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousZoomVelocitySpace.XRange.Max =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousZoomVelocitySpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousZoomVelocitySpace.XRange.Min =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousZoomVelocitySpace->XRange->Min;
                            //pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ContinuousZoomVelocitySpace.YRange = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ContinuousZoomVelocitySpace.YRange;

                            //7
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizePanTiltSpeedSpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizePanTiltSpeedSpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->PanTiltSpeedSpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.PanTiltSpeedSpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->PanTiltSpeedSpace->URI,MAX_URL_LEN);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.PanTiltSpeedSpace.XRange.Max =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->PanTiltSpeedSpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.PanTiltSpeedSpace.XRange.Min =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->PanTiltSpeedSpace->XRange->Min;
                            ONVIF_DBP("xmax= %d ,min= %d \n",pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.PanTiltSpeedSpace.XRange.Max,
                                      pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.PanTiltSpeedSpace.XRange.Min);


                            //8
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.__sizeZoomSpeedSpace =
                                    p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->__sizeZoomSpeedSpace;

                            if(p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ZoomSpeedSpace->URI)
                            {
                                strncpy(pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ZoomSpeedSpace.URI, p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ZoomSpeedSpace->URI,MAX_URL_LEN);
                            }
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ZoomSpeedSpace.XRange.Max =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ZoomSpeedSpace->XRange->Max;
                            pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ZoomSpeedSpace.XRange.Min =p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ZoomSpeedSpace->XRange->Min;
                            //pGetNodesResponse->PTZNode[k].SupportedPTZSpaces.ZoomSpeedSpace.YRange = p_tptz__GetNodesResponse->PTZNode[k].SupportedPTZSpaces->ZoomSpeedSpace.YRange;

                            pGetNodesResponse->PTZNode[k].MaximumNumberOfPresets = p_tptz__GetNodesResponse->PTZNode[k].MaximumNumberOfPresets;
                            pGetNodesResponse->PTZNode[k].HomeSupported = p_tptz__GetNodesResponse->PTZNode[k].HomeSupported;
                            pGetNodesResponse->PTZNode[k].__sizeAuxiliaryCommands =p_tptz__GetNodesResponse->PTZNode[k].__sizeAuxiliaryCommands;
                        }
                    }

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);
                    ONVIF_DBP("come here \n");
                    return soap->error;

}






int ONVIF_PtzGetPresets(Remote_Device_Info *pDeviceInfo, const char *profileToken, Onvif_Ptz_Presets *pGetPtzPresetsResponse )
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !pGetPtzPresetsResponse || !profileToken ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0 || index > MAX_CAMERA - 1 )
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _tptz__GetPresets *p__tptz__GetPresets =
            (struct _tptz__GetPresets *)soap_malloc(soap, sizeof(struct _tptz__GetPresets));

            memset(p__tptz__GetPresets, 0, sizeof(struct _tptz__GetPresets));

            p__tptz__GetPresets->ProfileToken = (char*)soap_malloc(soap, 128);
            memset(p__tptz__GetPresets->ProfileToken, 0, 128);

            if ( profileToken ) {
                strncpy(p__tptz__GetPresets->ProfileToken, profileToken, 127);
            }

            struct _tptz__GetPresetsResponse *p_tptz__GetPresetsResponse =
                    (struct _tptz__GetPresetsResponse *)soap_malloc(soap, sizeof(struct _tptz__GetPresetsResponse ));

                    soap_call___tptz__GetPresets(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p__tptz__GetPresets, p_tptz__GetPresetsResponse);

                    if ( !soap->error ) {

                        int k = 0;
                        int sizeOfPresets = p_tptz__GetPresetsResponse->__sizePreset;
                        sizeOfPresets = sizeOfPresets > MAX_PTZ_PRESETS - 1 ? MAX_PTZ_PRESETS - 1 : sizeOfPresets;

                        memset(pGetPtzPresetsResponse, 0, sizeof( Onvif_Ptz_Presets ) );
                        pGetPtzPresetsResponse->sizeOfPresets = sizeOfPresets;

                        for ( k = 0; k < sizeOfPresets; k++ ) {

                            if(p_tptz__GetPresetsResponse->Preset[k].Name)
                            {
                                strncpy(pGetPtzPresetsResponse->presets[k].presetName, p_tptz__GetPresetsResponse->Preset[k].Name, MAX_LEN - 1);
                            }
                            if(p_tptz__GetPresetsResponse->Preset[k].token)
                            {
                                strncpy(pGetPtzPresetsResponse->presets[k].presetToken, p_tptz__GetPresetsResponse->Preset[k].token, MAX_LEN - 1);
                            }
                        }
                    }

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);
                    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                    return soap->error;


}



int ONVIF_PtzStop(Remote_Device_Info *pDeviceInfo, const char *profileToken )
{

#if 1
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !profileToken ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&PTZ服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    bool pantilt = true;
    bool zoom = false ;
    struct _tptz__Stop *p_tptz__Stop =
            (struct _tptz__Stop *)soap_malloc(soap, sizeof(struct _tptz__Stop));
            memset(p_tptz__Stop, 0, sizeof( struct _tptz__Stop));

            p_tptz__Stop->PanTilt = (enum xsd__boolean * )soap_malloc(soap ,sizeof (enum xsd__boolean));
            p_tptz__Stop->Zoom = (enum xsd__boolean * )soap_malloc(soap ,sizeof (enum xsd__boolean));
            *p_tptz__Stop->PanTilt = pantilt ;
            *p_tptz__Stop->Zoom  = zoom;

            p_tptz__Stop->ProfileToken = (char*)soap_malloc(soap, 64);
            memset(p_tptz__Stop->ProfileToken, 0, 63);
            strncpy(p_tptz__Stop->ProfileToken, profileToken, 63);

            struct _tptz__StopResponse *p_tptz__StopResponse =
                    (struct _tptz__StopResponse *)soap_malloc(soap, sizeof(struct _tptz__StopResponse));

                    soap_call___tptz__Stop(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.pTZCapabilities.XAddr, NULL, p_tptz__Stop, p_tptz__StopResponse);

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }

                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);
                    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
                    return soap->error;

#endif
}





/***********************************************/

/****************IMAGE模块********************/

/***********************************************/



int ONVIF_GetImageOptions(Remote_Device_Info *pDeviceInfo, const char* videoSourceToken, Onvif_Img_Options *pGetImgOptionsResponse)
{

    if ( !pDeviceInfo || !pGetImgOptionsResponse || !videoSourceToken ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.mediaCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&IMage服务地址为空 \n");
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);

    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _timg__GetOptions p_timg__GetOptions ;
    p_timg__GetOptions.VideoSourceToken = (char*)soap_malloc(soap, 64);
    strncpy(p_timg__GetOptions.VideoSourceToken, videoSourceToken,63);
    struct _timg__GetOptionsResponse p_timg__GetOptionsResponse =  {0};

    soap_call___timg__GetOptions(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr, NULL, &p_timg__GetOptions, &p_timg__GetOptionsResponse);

    if ( !soap->error )
    {
        if ( p_timg__GetOptionsResponse.ImagingOptions )
        {

            if ( p_timg__GetOptionsResponse.ImagingOptions->Brightness )
            {
                pGetImgOptionsResponse->brightness.Max = p_timg__GetOptionsResponse.ImagingOptions->Brightness->Max;
                pGetImgOptionsResponse->brightness.Min = p_timg__GetOptionsResponse.ImagingOptions->Brightness->Min;
            }

            if ( p_timg__GetOptionsResponse.ImagingOptions->Contrast )
            {
                pGetImgOptionsResponse->Contrast.Max = p_timg__GetOptionsResponse.ImagingOptions->Contrast->Max;
                pGetImgOptionsResponse->Contrast.Min = p_timg__GetOptionsResponse.ImagingOptions->Contrast->Min;
            }

            if ( p_timg__GetOptionsResponse.ImagingOptions->ColorSaturation )
            {
                pGetImgOptionsResponse->ColorSaturation.Max = p_timg__GetOptionsResponse.ImagingOptions->ColorSaturation->Max;
                pGetImgOptionsResponse->ColorSaturation.Min = p_timg__GetOptionsResponse.ImagingOptions->ColorSaturation->Min;
            }
            if ( p_timg__GetOptionsResponse.ImagingOptions->Sharpness )
            {
                pGetImgOptionsResponse->Sharpness.Max = p_timg__GetOptionsResponse.ImagingOptions->Sharpness->Max;
                pGetImgOptionsResponse->Sharpness.Min = p_timg__GetOptionsResponse.ImagingOptions->Sharpness->Min;
            }
        }
    }
    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);

    return soap->error;

}


int ONVIF_GetImageConfiguration(Remote_Device_Info *pDeviceInfo, const char* videoSourceToken, Onvif_Img_Config *pGetImgConfigurationResponse)
{

    if ( !pDeviceInfo || !pGetImgConfigurationResponse || !videoSourceToken ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&IMage服务地址为空 \n");
        return -1;
    }

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = 1;
    soap->recv_timeout = 1;
    soap->send_timeout = 1;
#endif

    soap_set_namespaces(soap, namespaces);

    soap_header(soap);


    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _timg__GetImagingSettings *p_timg__GetImagingSettings =
            (struct _timg__GetImagingSettings *)soap_malloc(soap, sizeof( struct _timg__GetImagingSettings));
            memset(p_timg__GetImagingSettings, 0, sizeof( struct _timg__GetImagingSettings ));

            p_timg__GetImagingSettings->VideoSourceToken = (char*)soap_malloc(soap, 64);
            memset(p_timg__GetImagingSettings->VideoSourceToken, 0, 64);
            strncpy(p_timg__GetImagingSettings->VideoSourceToken, videoSourceToken, 63);

            struct _timg__GetImagingSettingsResponse *p_timg__GetImagingSettingsResponse =
                    (struct _timg__GetImagingSettingsResponse *)soap_malloc(soap, sizeof( struct _timg__GetImagingSettingsResponse));
                    memset(p_timg__GetImagingSettingsResponse, 0, sizeof(struct _timg__GetImagingSettingsResponse));

                    soap_call___timg__GetImagingSettings(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr, NULL, p_timg__GetImagingSettings, p_timg__GetImagingSettingsResponse);

                    if (!soap->error) {

                        if ( p_timg__GetImagingSettingsResponse->ImagingSettings ) {

                            if ( p_timg__GetImagingSettingsResponse->ImagingSettings->Brightness ) {
                                pGetImgConfigurationResponse->brightness = *p_timg__GetImagingSettingsResponse->ImagingSettings->Brightness;
                            }

                            if ( p_timg__GetImagingSettingsResponse->ImagingSettings->Contrast ) {
                                pGetImgConfigurationResponse->Contrast = *p_timg__GetImagingSettingsResponse->ImagingSettings->Contrast;
                            }

                            if ( p_timg__GetImagingSettingsResponse->ImagingSettings->ColorSaturation ) {
                                pGetImgConfigurationResponse->ColorSaturation = *p_timg__GetImagingSettingsResponse->ImagingSettings->ColorSaturation;
                            }

                            if ( p_timg__GetImagingSettingsResponse->ImagingSettings->Sharpness ) {
                                pGetImgConfigurationResponse->Sharpness = *p_timg__GetImagingSettingsResponse->ImagingSettings->Sharpness;
                                ONVIF_DBP("%f,%f,%f,%f",*p_timg__GetImagingSettingsResponse->ImagingSettings->Brightness,
                                          *p_timg__GetImagingSettingsResponse->ImagingSettings->Contrast,pGetImgConfigurationResponse->ColorSaturation,pGetImgConfigurationResponse->Sharpness);

                            }
                            ONVIF_DBP("%f,%f,%f,%f",*p_timg__GetImagingSettingsResponse->ImagingSettings->Brightness,
                                      *p_timg__GetImagingSettingsResponse->ImagingSettings->Contrast, *p_timg__GetImagingSettingsResponse->ImagingSettings->ColorSaturation, *p_timg__GetImagingSettingsResponse->ImagingSettings->Sharpness);
                        }
                    }

                    if (soap->error)
                    {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }


                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);

                    return soap->error;

}


int ONVIF_SetImageConfiguration(Remote_Device_Info *pDeviceInfo, const char* videoSourceToken, Onvif_Img_Config *pSetImgConfiguration)
{
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    if ( !pDeviceInfo || !pSetImgConfiguration || !videoSourceToken ) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if(index < 0 || index > MAX_CAMERA - 1)
    {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&IMage服务地址为空 \n");
        return -1;
    }
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = 2;
    soap->recv_timeout = 2;
    soap->send_timeout = 2;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    ONVIF_DBP("token : %s, brightness=%f,Contrast=%f,ColorSaturation=%f,Sharpness=%f \n", videoSourceToken,pSetImgConfiguration->brightness,pSetImgConfiguration->Contrast,pSetImgConfiguration->ColorSaturation,pSetImgConfiguration->Sharpness);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }
    struct _timg__SetImagingSettings *p_timg__SetImagingSettings =(struct _timg__SetImagingSettings *)soap_malloc(soap, sizeof( struct _timg__SetImagingSettings ));

    memset(p_timg__SetImagingSettings, 0, sizeof(struct _timg__SetImagingSettings));

    p_timg__SetImagingSettings->VideoSourceToken = (char*)soap_malloc(soap, 64);
    memset(p_timg__SetImagingSettings->VideoSourceToken, 0, 64);
    strncpy(p_timg__SetImagingSettings->VideoSourceToken, videoSourceToken, 63);

    p_timg__SetImagingSettings->ForcePersistence =
            (enum xsd__boolean*)soap_malloc(soap, sizeof( enum xsd__boolean));
    *p_timg__SetImagingSettings->ForcePersistence = true ;

    p_timg__SetImagingSettings->ImagingSettings =
            (struct tt__ImagingSettings20*)soap_malloc(soap, sizeof( struct tt__ImagingSettings20));
    memset(p_timg__SetImagingSettings->ImagingSettings, 0, sizeof(struct tt__ImagingSettings20));

    p_timg__SetImagingSettings->ImagingSettings->Brightness = (float*)soap_malloc(soap, sizeof(float));
    p_timg__SetImagingSettings->ImagingSettings->Contrast = (float*)soap_malloc(soap, sizeof(float));
    p_timg__SetImagingSettings->ImagingSettings->ColorSaturation = (float*)soap_malloc(soap, sizeof(float));
    p_timg__SetImagingSettings->ImagingSettings->Sharpness = (float*)soap_malloc(soap, sizeof(float));

    *p_timg__SetImagingSettings->ImagingSettings->Brightness = pSetImgConfiguration->brightness;
    *p_timg__SetImagingSettings->ImagingSettings->Contrast = pSetImgConfiguration->Contrast;
    *p_timg__SetImagingSettings->ImagingSettings->ColorSaturation = pSetImgConfiguration->ColorSaturation;
    *p_timg__SetImagingSettings->ImagingSettings->Sharpness = pSetImgConfiguration->Sharpness;

    struct _timg__SetImagingSettingsResponse *p_timg__SetImagingSettingsResponse =(struct _timg__SetImagingSettingsResponse *)soap_malloc(soap, sizeof(struct _timg__SetImagingSettingsResponse));

    soap_call___timg__SetImagingSettings(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.imagingCapabilities.XAddr, NULL, p_timg__SetImagingSettings, p_timg__SetImagingSettingsResponse);

    if (soap->error)
    {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }

    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);
    soap->error = (soap->error == 0 ? 1 : -1);
    ONVIF_DBP("################%s\n",pDeviceInfo->ip);
    return soap->error;

}


int msSleep(long ms)
{
    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = ms * 1000;
    return select(0, NULL, NULL, NULL, &tv);
}


pthread_mutex_t g_eventLock;



#if 1

/*********************************************/
/**************事件模块************************/
/*********************************************/


int ONVIF_GetLocalIP(char *ifname, char * ip_buf)
{

    // fprintf(stderr,"@@@@@@@@@@@@@@get ip  %s :%d \n",__func__,__LINE__);
    struct ifreq ifr;
    int skfd;
    struct sockaddr_in *saddr;

    if ( (skfd = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
        // fprintf(stderr,"socket error\n");
        return -1;
    }
    memset(&ifr, 0, sizeof( struct ifreq));
    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
    if (ioctl(skfd, SIOCGIFADDR, &ifr) < 0) {
        // fprintf(stderr,"net_get_ifaddr: ioctl SIOCGIFADDR\n");
        close(skfd);
        return -1 ;
    }

    saddr = (struct sockaddr_in *) &ifr.ifr_addr;
    strcpy(ip_buf, inet_ntoa(saddr->sin_addr));
    // fprintf(stderr,"@@@@@@@@@@@@@@%s\n",ip_buf);
    close(skfd);
    return 0;
}



typedef union __NET_IPV4
{
    int  int32;
    char str[4];
} NET_IPV4;



int ONVIF_EventSubscribe(Remote_Device_Info *pDeviceInfo)
{
#if 1
    if ( !pDeviceInfo) {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int error = GetCapabilities(pDeviceInfo);
    if ( 1 != error )
    {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0  || index >= MAX_CAMERA ) {
        return -1;
    }
    if(!g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.XAddr)
    {
        ONVIF_DBP(" &&&&&&&&&&&&&IMage服务地址为空 \n");
        return -1;
    }

    ONVIF_DBP("endpoint %s \n", g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.XAddr);
    char eventAddr[MAX_STRING_LENGTH] = { 0 };

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _tev__GetEventPropertiesResponse *p_tev__GetEventPropertiesResponse =
            ( struct _tev__GetEventPropertiesResponse * )soap_malloc(soap, sizeof(struct _tev__GetEventPropertiesResponse ) );
            memset(p_tev__GetEventPropertiesResponse, 0, sizeof(  struct _tev__GetEventPropertiesResponse ) );
            struct _tev__GetEventProperties *p_tev__GetEventProperties =
                    (struct _tev__GetEventProperties *)soap_malloc(soap, sizeof(struct _tev__GetEventProperties));
                    memset(p_tev__GetEventProperties, 0, sizeof(struct _tev__GetEventProperties));

                    soap_call___ns2__GetEventProperties(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.XAddr, NULL, p_tev__GetEventProperties, p_tev__GetEventPropertiesResponse);

                    int size = 0;
                    int k = 0;

                    if (!soap->error) {
                        if ( soap->header ) {
                            if ( soap->header->wsa__To ) {
                                strncpy(eventAddr, soap->header->wsa__To, MAX_STRING_LENGTH - 1 );
                                ONVIF_DBP("eventAddr %s \n", eventAddr);
                            }
                        }

                        if ( p_tev__GetEventPropertiesResponse->wstop__TopicSet) {
                            size = p_tev__GetEventPropertiesResponse->wstop__TopicSet->__size;
                            if ( size > 0 ) {
                                for (k = 0; k < size; k++ ) {
                                    //ONVIF_DBP(" any[%d] %s \n", k, p_tev__GetEventPropertiesResponse->wstop__TopicSet->__any[k] );
                                }
                            }
                        }
                    }

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    if ( soap->error )
                    {
                        ONVIF_DBP("!!!!!!!!!!!!!!!!不支持事件订阅！！！！！！！！！！！！！！！！！", eventAddr);
                        return -1;
                    }

                    ONVIF_DBP("!!!!!!!!!!!!!!!!开始事件订阅！！！！！！！！！！！！！！！！！", eventAddr);

                    soap_init(soap);

#ifdef ONVIF_TIMEOUT
                    soap->connect_timeout = g_onvif_time_out;
                    soap->recv_timeout = g_onvif_time_out;
                    soap->send_timeout = g_onvif_time_out;
#endif

                    soap_set_namespaces(soap, namespaces);
                    soap_header(soap);
                    //权限认证
                    if(pDeviceInfo->userName[0])
                    {
                        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
                    }


                    struct _wsnt__Subscribe *p_wsnt__Subscribe =
                            (struct _wsnt__Subscribe *)soap_malloc(soap, sizeof(struct _wsnt__Subscribe ));
                            memset(p_wsnt__Subscribe, 0, sizeof(struct _wsnt__Subscribe ));
                            //memset(&p_wsnt__Subscribe->ConsumerReference, 0, sizeof(struct wsa__EndpointReferenceType));
                            p_wsnt__Subscribe->ConsumerReference.Address = (char*)soap_malloc(soap, MAX_STRING_LENGTH);
                            memset(p_wsnt__Subscribe->ConsumerReference.Address, 0, MAX_STRING_LENGTH - 1);
                            char ip_buff[32];

                            ONVIF_GetLocalIP("eth0", ip_buff);
                            sprintf(p_wsnt__Subscribe->ConsumerReference.Address, "http://%s:8181/",
                                    ip_buff);
                            // fprintf(stderr,"p_wsnt__Subscribe->ConsumerReference.Address=%s\n",p_wsnt__Subscribe->ConsumerReference.Address);

                            ONVIF_DBP("!!!!!!!!!!!!!!!!开始事件订阅！！！！！！！！！！！！！！！！！%s\n", p_wsnt__Subscribe->ConsumerReference.Address);

                            p_wsnt__Subscribe->InitialTerminationTime = (char*)soap_malloc(soap, MAX_STRING_LENGTH);
                            strcpy(p_wsnt__Subscribe->InitialTerminationTime, "PT60S");

                            struct _wsnt__SubscribeResponse *p_wsnt__SubscribeResponse =
                                    (struct _wsnt__SubscribeResponse *)soap_malloc(soap, sizeof(struct _wsnt__SubscribeResponse ));
                                    memset(p_wsnt__SubscribeResponse, 0, sizeof(struct _wsnt__SubscribeResponse));

                                    soap_call___ns4__Subscribe(soap, g_onvifCameras.onvif_info[index].tdsCapabilities.eventCapabilities.XAddr, NULL, p_wsnt__Subscribe, p_wsnt__SubscribeResponse);

                                    if ( !soap->error)
                                    {
                                        int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );

                                        if ( (-1 != index) && index < MAX_CAMERA )
                                        {
                                            if ( p_wsnt__SubscribeResponse->TerminationTime )
                                            {
                                                ONVIF_DBP("TerminationTime %d \n", *p_wsnt__SubscribeResponse->TerminationTime);
                                                g_onvifCameras.CameraEvents[index].endTime =
                                                        *p_wsnt__SubscribeResponse->TerminationTime;
                                            }

                                            if ( p_wsnt__SubscribeResponse->CurrentTime ) {
                                                ONVIF_DBP("wsnt__CurrentTime %d \n", *p_wsnt__SubscribeResponse->CurrentTime);

                                                g_onvifCameras.CameraEvents[index].currentTime =
                                                        *p_wsnt__SubscribeResponse->CurrentTime;
                                                g_onvifCameras.CameraEvents[index].startTime =
                                                        *p_wsnt__SubscribeResponse->CurrentTime;

                                            }

                                            if ( p_wsnt__SubscribeResponse->SubscriptionReference.Address ) {

                                                strncpy(g_onvifCameras.CameraEvents[index].subscribeUrl,
                                                        p_wsnt__SubscribeResponse->SubscriptionReference.Address,
                                                        MAX_STRING_LENGTH - 1);
                                                ONVIF_DBP("SubscriptionReference->Address %s\n", p_wsnt__SubscribeResponse->SubscriptionReference.Address);
                                                // ONVIF_DBP("SubscriptionReference->Address %s", g_onvifCameras.CameraEvents[index].subscribeUrl);

                                                g_onvifCameras.CameraEvents[index].subscribeUrl[MAX_STRING_LENGTH - 1] = '\0';
                                            }
                                        }
                                    }

                                    if (soap->error) {
                                        fprintf(stderr,"soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                                    }
                                    soap_destroy(soap);
                                    soap_end(soap);
                                    soap_done(soap);

                                    soap->error = (soap->error == 0 ? 1 : -1);

                                    return soap->error;
#endif

}


int ONVIF_EventUnSubscribe(Remote_Device_Info *pDeviceInfo)
{

    if ( !pDeviceInfo)
    {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    char endpoint[MAX_STRING_LENGTH];
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );
    if ( index < 0  || index >= MAX_CAMERA ) {
        return -1;
    }
    ONVIF_DBP("@@@@@@@@@@@@@%s:%d:%s\n",__func__,__LINE__,g_onvifCameras.CameraEvents[index].subscribeUrl);
    if ( !g_onvifCameras.CameraEvents[index].subscribeUrl[0])
    {
        return -1;
    }

    ONVIF_DBP("endpoint %s \n", g_onvifCameras.CameraEvents[index].subscribeUrl);

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif
    soap_set_namespaces(soap, namespaces);
    soap_header(soap);

    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }



    struct _wsnt__Unsubscribe *p_wsnt__Unsubscribe =
            (struct _wsnt__Unsubscribe *)soap_malloc(soap, sizeof(struct _wsnt__Unsubscribe ));
            memset(p_wsnt__Unsubscribe, 0, sizeof(struct _wsnt__Unsubscribe));

            struct _wsnt__UnsubscribeResponse *p_wsnt__UnsubscribeResponse =
                    (struct _wsnt__UnsubscribeResponse *)soap_malloc(soap, sizeof(struct _wsnt__UnsubscribeResponse ));
                    memset(p_wsnt__UnsubscribeResponse, 0, sizeof(struct _wsnt__UnsubscribeResponse));


                    soap_call___ns8__Unsubscribe(soap, g_onvifCameras.CameraEvents[index].subscribeUrl, NULL, p_wsnt__Unsubscribe, p_wsnt__UnsubscribeResponse);

                    if (soap->error)
                    {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);

                    return soap->error;
}



int ONVIF_EventRenew(Remote_Device_Info *pDeviceInfo)
{
#if 1
    if ( !pDeviceInfo) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );

    if ( index < 0  || index >= MAX_CAMERA ) {
        return -1;
    }

    if ( !g_onvifCameras.CameraEvents[index].subscribeUrl )
    {
        return -1;
    }
    ONVIF_DBP("endpoint %s \n", g_onvifCameras.CameraEvents[index].subscribeUrl);

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //权限认证
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }


    struct _wsnt__Renew  * p_wsnt__Renew  = (struct _wsnt__Renew  *) soap_malloc(soap,sizeof(struct _wsnt__Renew));
    memset(p_wsnt__Renew,0,sizeof(struct _wsnt__Renew));
    p_wsnt__Renew->TerminationTime = (char*)soap_malloc(soap, MAX_STRING_LENGTH);
    strcpy(p_wsnt__Renew->TerminationTime, "PT240S");


    struct _wsnt__RenewResponse  * p_wsnt__RenewResponse  = (struct _wsnt__RenewResponse  *) soap_malloc(soap,sizeof(struct _wsnt__RenewResponse));
    memset(p_wsnt__RenewResponse,0,sizeof(struct _wsnt__RenewResponse));
    soap_call___ns3__Renew(soap, g_onvifCameras.CameraEvents[index].subscribeUrl, NULL, p_wsnt__Renew, p_wsnt__RenewResponse);

    if (!soap->error)
    {
        ONVIF_DBP("p_wsnt__RenewResponse end time %d \n", p_wsnt__RenewResponse->TerminationTime );
        pthread_mutex_lock(&g_eventLock);

        if ( p_wsnt__RenewResponse->CurrentTime )
        {
            g_onvifCameras.CameraEvents[index].startTime =  *p_wsnt__RenewResponse->CurrentTime ;
            ONVIF_DBP("p_wsnt__RenewResponse curent time %d \n", *p_wsnt__RenewResponse->CurrentTime);
        }
        g_onvifCameras.CameraEvents[index].endTime = p_wsnt__RenewResponse->TerminationTime ;
        pthread_mutex_unlock(&g_eventLock);

        ONVIF_DBP("%s renew get endTime %d \n", g_onvifCameras.CameraEvents[index].subscribeUrl,
                  p_wsnt__RenewResponse->TerminationTime);

    }

    if (soap->error) {
        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
    }
    soap_destroy(soap);
    soap_end(soap);
    soap_done(soap);

    soap->error = (soap->error == 0 ? 1 : -1);

    return soap->error;

#endif
}




int g_threadEventExit = 0;
pthread_t g_threadEventM = -1;
pthread_t g_threadEventServer = -1;

ONVIF_EventCallback g_EventCallback = NULL;


#if 0
void *thread_EventRenew( void *arg )
{
    Remote_Device_Info *pDeviceInfo = (Remote_Device_Info*)arg;

    ONVIF_DBP(" Enter\n");

    if ( !pDeviceInfo ) {
        return;
    }

    ONVIF_DBP(" ip %s port %d\n", pDeviceInfo->ip, pDeviceInfo->port);

    ONVIF_EventRenew(pDeviceInfo);

    ONVIF_DBP(" exit \n");

}
#endif

void *thread_EventManager( void* args )
{
    int i = 0;
    Remote_Device_Info pDeviceInfo;

    while ( !g_threadEventExit )
    {
        // fprintf(stderr,"%s:%d \n",__func__,__LINE__);

        for (i = 0; i < MAX_CAMERA - 1; i++ )
        {

            if ( g_onvifCameras.CameraEvents[i].subscribeUrl[0] )
            {

                pthread_mutex_lock(&g_eventLock);
                g_onvifCameras.CameraEvents[i].startTime++;
                pthread_mutex_unlock(&g_eventLock);
                // fprintf(stderr,"%s:%d :%d  %d\n",__func__,__LINE__,g_onvifCameras.CameraEvents[i].startTime,g_onvifCameras.CameraEvents[i].endTime);
                if ( g_onvifCameras.CameraEvents[i].startTime + 60 > g_onvifCameras.CameraEvents[i].endTime)
                {
                    //fprintf(stderr,"%s:%d :%s\n",__func__,__LINE__,g_onvifCameras.CameraEvents[i].subscribeUrl);
                    ONVIF_DBP(" url %s renew \n", g_onvifCameras.CameraEvents[i].subscribeUrl );
                    // renew
                    // pthread_t th;
                    //pthread_create(&th, NULL, thread_EventRenew, (void*)&g_onvifCameras.cameraIpInfo[i]);
                    strcpy(pDeviceInfo.ip, g_onvifCameras.cameraIpInfo[i].ip);
                    strcpy(pDeviceInfo.userName, g_onvifCameras.cameraIpInfo[i].User);
                    strcpy(pDeviceInfo.password, g_onvifCameras.cameraIpInfo[i].Password);
                    pDeviceInfo.port =g_onvifCameras.cameraIpInfo[i].port;
                    ONVIF_EventRenew(&pDeviceInfo);
                    // fprintf(stderr,"%s:%d :%s :%s\n",__func__,__LINE__,pDeviceInfo.userName,pDeviceInfo.password);
                }
            }
        }
        usleep(800 *1000*2);
    }
    g_threadEventM = -1;
    pthread_mutex_destroy(&g_eventLock);
    ONVIF_DBP(" EXIT thread_EventManager \n");

}



int Onvif_EventListen( )
{
    int sockOptVal = 1;
    struct sockaddr_in svrAddr;
    int serverSocket = -1;

    serverSocket = socket(PF_INET, SOCK_STREAM, 0);
    if(-1 == serverSocket){
        return -1;
    }
    if (-1 == setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &sockOptVal, sizeof(int))) {
        close(serverSocket);
        return -1;
    }

    memset(&svrAddr, 0, sizeof(svrAddr));
    svrAddr.sin_addr.s_addr 	= htonl(INADDR_ANY);
    svrAddr.sin_family 		= AF_INET;
    svrAddr.sin_port  		= htons(8181);

    if (-1 == bind(serverSocket, (struct sockaddr *)&svrAddr, sizeof(struct sockaddr))){
        close(serverSocket);
        return -1;
    }

    if (-1 == listen(serverSocket, SOMAXCONN )){
        close(serverSocket);
        return -1;
    }

    return serverSocket;

}



int EventHandle( char* pBuf )
{
    if ( !pBuf ) {
        return -1;
    }

    char *pStart = pBuf;
    char *pAction = NULL;

    char *space = "http://docs.oasis-open.org/wsn/bw-2/NotificationConsumer/Notify";

#if  0
    pStart = (char*)strcasestr(pBuf, "action");

    if ( pStart ) {
        pAction = pStart + strlen("action") + 1;
        pStart = pAction;
        pStart += strlen(space);
        *pStart = '\0';
    }

    //printf("action %s \n", pAction);

    // Name="AlarmType" Value="AlarmLocal


    pStart += 1;



    fprintf(stderr,"alarm value \n" );
    pStart = (char*)strcasestr(pBuf, "ismotion");

    if ( pStart )
    {
        pStart = strstr(pStart, "Value");

        if ( pStart )
        {
            pStart += strlen("Value=\"");

            char *pValue = pStart;

            pStart = strstr(pStart, "\"");
            *pStart = '\0';

            fprintf(stderr,"alarm value %s \n", pValue);

            if ( strcmp(pValue, "true" ) == 0 )
            {
                return 1;
            }
            if ( strcmp( pValue, "false" ) == 0 )
            {
                return 2;
            }

        }
    }
#endif
    pStart = (char*)strcasestr(pBuf, "ismotion");
    if (pStart)
    {
        pAction = (char*)strcasestr(pStart, "value=\"true\"");
        if(pAction)
        {
            return  2;
        }
        pAction = (char*)strcasestr(pStart, "value=\"false\"");
        if(pAction)
        {
            return  1;
        }
    }

    return 0;

}

char recvBuf[1024*20];

void *thread_EventServer( void* args  )
{

    int svrSockFd, cliSockFd;
    int maxFd = 0;
    int ret, sockOptVal = 1;
    socklen_t addrLen;

    int recvLen = 0;

    struct sockaddr_in cliAddr;
    struct linger  socklinger;
    struct timeval timeout;

    svrSockFd = Onvif_EventListen();

    if ( -1 == svrSockFd ) {
        return;
    }

    fd_set sockFds;

    while ( !g_threadEventExit )
    {
        FD_ZERO(&sockFds);
        FD_SET(svrSockFd, &sockFds);

        maxFd = svrSockFd;

        timeout.tv_sec  = 2;
        timeout.tv_usec = 0;	// 2 s timeout
        // fprintf(stderr,"%s:%d\r\n ",__func__,__LINE__);
        ret = select(maxFd + 1, &sockFds, NULL, NULL, &timeout);
        // fprintf(stderr,"%s:%d\r\n ",__func__,__LINE__);
        if(ret < 0){
            if(errno == EINTR)
            {
                continue;
            }

            break;
        } else if(ret == 0)
        {
            continue;
            sleep(2);

        } else {

            if (FD_ISSET(svrSockFd, &sockFds))
            {
                addrLen = sizeof(cliAddr);
                cliSockFd = accept(svrSockFd, (struct sockaddr *)&cliAddr,&addrLen);
                if(cliSockFd <= 0){
                    // fprintf(stderr, "%s :%d: accept \r\n", __FILE__, __LINE__);
                    continue;
                }
                //fprintf(stderr, "%s :%d: accept \r\n", __FILE__, __LINE__);
                //dbg(Dbg, DbgNoPerror, "accept a client\n");
                socklinger.l_onoff	= 1;
                socklinger.l_linger = 0;
                timeout.tv_sec  = 2;  // 3
                timeout.tv_usec = 0;
                if ( -1 == setsockopt(cliSockFd, SOL_SOCKET, SO_RCVTIMEO,(char*)&timeout, sizeof(timeout))){
                    //dbg(Err, DbgPerror, "setsockopt cliSockFd = %d error\n",cliSockFd);
                }
                if ( -1 == setsockopt(cliSockFd, SOL_SOCKET, SO_LINGER,  &socklinger, sizeof(socklinger))){
                    //dbg(Err, DbgPerror, "setsockopt cliSockFd = %d error\n",cliSockFd);
                }
                if ( -1 == setsockopt(cliSockFd, IPPROTO_TCP, TCP_NODELAY, &sockOptVal, sizeof(int))){
                    //dbg(Err, DbgPerror, "setsockopt cliSockFd = %d error\n",cliSockFd);
                }


                int ret = 0;
                recvLen = 0;
                int leftLen = 10240;
                // fprintf(stderr, "%s :%d: accept \r\n", __FILE__, __LINE__);
                while ( leftLen > 0 ) {

                    ret = recv(cliSockFd, recvBuf+recvLen, leftLen, 0);
                    if (ret <= 0) {

                        break;
                    }

                    // fprintf(stderr, "%s :%d: recv %d  \r\n", __FILE__, __LINE__,ret);
                    recvLen += ret;
                    leftLen -= ret;
                    usleep(100*1000);
                }

                // fprintf(stderr, "%s :%d: recvLen %d \r\n recvBuf: %s \r\n", __FILE__, __LINE__, recvLen,recvBuf);
                // fprintf(stderr, "%s :%d: recv \r\n", __FILE__, __LINE__);
                if ( recvLen > 0 ) {
                    int eventType = EventHandle(recvBuf);

                    if ( eventType >= 0 && g_EventCallback ) {
                        char ipaddr[MAX_IP_LEN] = { 0 };

                        // fprintf(stderr,"==================got motiondetect  , ip %s , type =%d \n", inet_ntoa(cliAddr.sin_addr),eventType );
                        sprintf(ipaddr, "%s", inet_ntoa(cliAddr.sin_addr));
                        g_EventCallback(ipaddr, eventType);
                    }
                }

                close(cliSockFd);
                cliSockFd = -1;

            }
        }
    }

    g_threadEventServer = -1;

    ONVIF_DBP(" EXIT thread_EventServer \n");


}

int ONVIF_EventServerStart( ONVIF_EventCallback pEventCallback )
{
#if  1
    if ( pEventCallback ) {
        g_EventCallback = pEventCallback;
    }

    if ( -1 == g_threadEventM )
    {
        pthread_mutex_init(&g_eventLock, NULL);

        pthread_create(&g_threadEventM, NULL, thread_EventManager, NULL);

        pthread_create(&g_threadEventServer, NULL, thread_EventServer, NULL);
    }

#endif
}

int ONVIF_EventServerStop()
{
    g_threadEventExit = 1;

    sleep(3);

    if ( -1 != g_threadEventM) {
        pthread_join(g_threadEventM, NULL);
        g_threadEventM = -1;
    }

    if ( -1 != g_threadEventServer ) {
        pthread_join(g_threadEventServer, NULL);
        g_threadEventServer = -1;
    }
    pthread_mutex_destroy (&g_eventLock);
}



#endif



int ONVIF_GetNetworkInterfaces(Remote_Device_Info *pDeviceInfo ,NetworkInterfaces * AllInterface)
{
    if ( !pDeviceInfo) {
        return -1;
    }
    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }
    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );

    if ( index < 0  || index >= MAX_CAMERA ) {
        return -1;
    }
    if ( !g_onvifCameras.CameraEvents[index].subscribeUrl)
    {
        return -1;
    }
    ONVIF_DBP("endpoint --%s-- \n", g_onvifCameras.CameraEvents[index].subscribeUrl);
    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);

    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _tds__GetNetworkInterfaces * tds__GetNetworkInterfaces =
            ( struct _tds__GetNetworkInterfaces *)soap_malloc(soap,sizeof( struct _tds__GetNetworkInterfaces ));

            struct _tds__GetNetworkInterfacesResponse * tds__GetNetworkInterfacesResponse =
                    ( struct _tds__GetNetworkInterfacesResponse *)soap_malloc(soap,sizeof( struct _tds__GetNetworkInterfacesResponse ));

                    char pEndPointStr[MAX_STRING_LENGTH];
                    sprintf(pEndPointStr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);

                    soap_call___tds__GetNetworkInterfaces(soap, pEndPointStr , NULL, tds__GetNetworkInterfaces, tds__GetNetworkInterfacesResponse);
                    if (!soap->error)
                    {
                        AllInterface->__sizeNetworkInterfaces =tds__GetNetworkInterfacesResponse->__sizeNetworkInterfaces;

                        int i ;
                        for(i=0 ; i!= tds__GetNetworkInterfacesResponse->__sizeNetworkInterfaces;++i)
                        {
                            strncpy(AllInterface->SingleNetworkInterface[i].token , tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].token,MAX_STRING_LENGTH);
                            AllInterface->SingleNetworkInterface[i].Enable = tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].Enabled;
                            strncpy(AllInterface->SingleNetworkInterface[i].InterfaceName , tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].Info->Name,MAX_STRING_LENGTH);
                            strncpy(AllInterface->SingleNetworkInterface[i].HwAddress , tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].Info->HwAddress,MAX_STRING_LENGTH);
                            strncpy(AllInterface->SingleNetworkInterface[i].IpAddress ,tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].IPv4->Config->Manual->Address,MAX_STRING_LENGTH);
                            AllInterface->SingleNetworkInterface[i].DHCP =tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].IPv4->Config->DHCP;
                            AllInterface->SingleNetworkInterface[i].NetMaskLength =tds__GetNetworkInterfacesResponse->NetworkInterfaces[i].IPv4->Config->Manual->PrefixLength;
                        }
                    }

                    if (soap->error) {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);

                    soap->error = (soap->error == 0 ? 1 : -1);

                    return soap->error;


}



void vMaskToPrefix( char *  p_strXAddr, int *p_iPrefixLength)
{
    int l_iPrefixLength = 0;
    int netMask = inet_addr(p_strXAddr);
    while(netMask>0){
        netMask = netMask >> 1;
        l_iPrefixLength++;
    }
    *p_iPrefixLength = l_iPrefixLength;

#if 0
    int l_iPrefixLength = 0;
    int l_iTemp = 0;
    int i ;
    for(  i  = 0; i != strlen(p_strXAddr); ++i )
    {
        if( isdigit(p_strXAddr[i]))
        {

            l_iTemp = l_iTemp * 10 + (p_strXAddr[i] - '0');
        }
        else
        {

            switch(l_iTemp)
            {
            case 255:
                l_iPrefixLength += 8;
                break;
            case 254:
                l_iPrefixLength += 7;
                break;
            case 252:
                l_iPrefixLength += 6;
                break;
            case 248:
                l_iPrefixLength += 5;
                break;
            case 240:
                l_iPrefixLength += 4;
                break;
            case 224:
                l_iPrefixLength += 3;
                break;
            case 192:
                l_iPrefixLength += 2;
                break;
            case 128:
                l_iPrefixLength += 1;
                break;
            case 0:
                l_iPrefixLength += 0;
                break;
            default:
                break;
            }
            l_iTemp = 0;
        }
    }

#endif
    p_iPrefixLength = l_iPrefixLength;
}




int ONVIF_SetNetworkInterfaces(Remote_Device_Info *pDeviceInfo ,char * token ,char * ipaddr, char * netmask,bool dhcp)
{
    if ( !pDeviceInfo) {
        return -1;
    }

    if ( !pDeviceInfo->ip[0] ) {
        return -1;
    }

    int index = ONVIF_GetCameraIndex( pDeviceInfo->ip );

    if ( index < 0  || index >= MAX_CAMERA ) {
        return -1;
    }

#if 0
    if ( !g_onvifCameras.CameraEvents[index].subscribeUrl )
    {
        return -1;
    }
#endif
    ONVIF_DBP("endpoint %s \n", g_onvifCameras.CameraEvents[index].subscribeUrl);

    struct soap  soap_client;
    struct soap *soap = &soap_client;
    soap_init(soap);

#ifdef ONVIF_TIMEOUT
    soap->connect_timeout = g_onvif_time_out;
    soap->recv_timeout = g_onvif_time_out;
    soap->send_timeout = g_onvif_time_out;
#endif

    soap_set_namespaces(soap, namespaces);
    soap_header(soap);
    //鏉冮檺璁よ瘉
    if(pDeviceInfo->userName[0])
    {
        ONVIF_SetAuthenticationInformation(soap,pDeviceInfo->userName,pDeviceInfo->password);
    }

    struct _tds__SetNetworkInterfaces * tds__SetNetworkInterfaces =
            ( struct _tds__SetNetworkInterfaces *)soap_malloc(soap,sizeof( struct _tds__SetNetworkInterfaces ));

            tds__SetNetworkInterfaces->InterfaceToken =
                    ( char *)soap_malloc(soap,MAX_STRING_LENGTH);
            tds__SetNetworkInterfaces->NetworkInterface =
                    ( struct tt__NetworkInterfaceSetConfiguration *)soap_malloc(soap,sizeof( struct tt__NetworkInterfaceSetConfiguration ));
            memset(tds__SetNetworkInterfaces->NetworkInterface,0,sizeof(struct tt__NetworkInterfaceSetConfiguration));


            tds__SetNetworkInterfaces->NetworkInterface->Enabled =  ( enum xsd__boolean *)soap_malloc(soap,sizeof(enum xsd__boolean));
            tds__SetNetworkInterfaces->NetworkInterface->IPv4 = ( struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_malloc(soap,sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration));

#if 1
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->Enabled = ( enum xsd__boolean *)soap_malloc(soap,sizeof(enum xsd__boolean));
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->Manual = ( struct tt__PrefixedIPv4Address *)soap_malloc(soap,sizeof(struct tt__PrefixedIPv4Address));
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->Manual->Address = (char *)soap_malloc(soap,MAX_STRING_LENGTH);
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->Manual->Address[0] = 0;
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->DHCP = ( enum xsd__boolean *)soap_malloc(soap,sizeof(enum xsd__boolean));

            enum xsd__boolean InterfaceEnable = true ;
            int PrefixLength = 0 ;
            vMaskToPrefix(netmask,&PrefixLength);
            strncpy( tds__SetNetworkInterfaces->InterfaceToken,token,MAX_STRING_LENGTH);

            *tds__SetNetworkInterfaces->NetworkInterface->Enabled = InterfaceEnable;
            *tds__SetNetworkInterfaces->NetworkInterface->IPv4->Enabled = InterfaceEnable;
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->__sizeManual = 1;

            strncpy(tds__SetNetworkInterfaces->NetworkInterface->IPv4->Manual->Address,ipaddr,MAX_STRING_LENGTH);
            tds__SetNetworkInterfaces->NetworkInterface->IPv4->Manual->PrefixLength   =  PrefixLength;

            *tds__SetNetworkInterfaces->NetworkInterface->IPv4->DHCP = dhcp;
#endif

            char pEndPointStr[MAX_STRING_LENGTH];
            sprintf(pEndPointStr,"http://%s:%d/onvif/device_service",pDeviceInfo->ip,pDeviceInfo->port);

            struct _tds__SetNetworkInterfacesResponse * tds__SetNetworkInterfacesResponse =
                    ( struct _tds__SetNetworkInterfacesResponse *)soap_malloc(soap,sizeof( struct _tds__SetNetworkInterfacesResponse ));


                    soap_call___tds__SetNetworkInterfaces(soap,pEndPointStr, NULL, tds__SetNetworkInterfaces, tds__SetNetworkInterfacesResponse);

                    if (soap->error)
                    {
                        ONVIF_DBP("soap error: %s, %s\n", *soap_faultcode(soap), *soap_faultstring(soap));
                    }
                    soap_destroy(soap);
                    soap_end(soap);
                    soap_done(soap);
                    soap->error = (soap->error == 0 ? 1 : -1);

                    return soap->error;

}

